var self=undefined||{};try{self.WeakMap=WeakMap}catch(WeakMap){self.WeakMap=function(id,Object){var dP=Object.defineProperty;var hOP=Object.hasOwnProperty;var proto=WeakMap.prototype;proto.delete=function(key){return this.has(key)&&delete key[this._]};proto.get=function(key){return this.has(key)?key[this._]:void 0};proto.has=function(key){return hOP.call(key,this._)};proto.set=function(key,value){dP(key,this._,{configurable:true,value:value});return this};return WeakMap;function WeakMap(iterable){dP(this,"_",{value:"_@ungap/weakmap"+id++});if(iterable)iterable.forEach(add,this)}function add(pair){this.set(pair[0],pair[1])}}(Math.random(),Object)}var WeakMap$1=self.WeakMap;var self$1=undefined||{};try{self$1.WeakSet=WeakSet}catch(WeakSet){(function(id,dP){var proto=WeakSet.prototype;proto.add=function(object){if(!this.has(object))dP(object,this._,{value:true,configurable:true});return this};proto.has=function(object){return this.hasOwnProperty.call(object,this._)};proto.delete=function(object){return this.has(object)&&delete object[this._]};self$1.WeakSet=WeakSet;function WeakSet(){dP(this,"_",{value:"_@ungap/weakmap"+id++})}})(Math.random(),Object.defineProperty)}var WeakSet$1=self$1.WeakSet;var self$2=undefined||{};try{self$2.Map=Map}catch(Map){self$2.Map=function Map(){var i=0;var k=[];var v=[];return{delete:function(key){var had=contains(key);if(had){k.splice(i,1);v.splice(i,1)}return had},forEach:function forEach(callback,context){k.forEach(function(key,i){callback.call(context,v[i],key,this)},this)},get:function get(key){return contains(key)?v[i]:void 0},has:function has(key){return contains(key)},set:function set(key,value){v[contains(key)?i:k.push(key)-1]=value;return this}};function contains(v){i=k.indexOf(v);return-1<i}}}var Map$1=self$2.Map;const append=(get,parent,children,start,end,before)=>{const isSelect="selectedIndex"in parent;let selectedIndex=-1;while(start<end){const child=get(children[start],1);if(isSelect&&selectedIndex<0&&child.selected)selectedIndex=start;parent.insertBefore(child,before);start++}if(isSelect&&-1<selectedIndex)parent.selectedIndex=selectedIndex};const eqeq=(a,b)=>a==b;const identity=O=>O;const indexOf=(moreNodes,moreStart,moreEnd,lessNodes,lessStart,lessEnd,compare)=>{const length=lessEnd-lessStart;if(length<1)return-1;while(moreEnd-moreStart>=length){let m=moreStart;let l=lessStart;while(m<moreEnd&&l<lessEnd&&compare(moreNodes[m],lessNodes[l])){m++;l++}if(l===lessEnd)return moreStart;moreStart=m+1}return-1};const isReversed=(futureNodes,futureEnd,currentNodes,currentStart,currentEnd,compare)=>{while(currentStart<currentEnd&&compare(currentNodes[currentStart],futureNodes[futureEnd-1])){currentStart++;futureEnd--}return futureEnd===0};const next=(get,list,i,length,before)=>i<length?get(list[i],0):0<i?get(list[i-1],-0).nextSibling:before;const remove=(get,parent,children,start,end)=>{if(end-start<2)parent.removeChild(get(children[start],-1));else{const range=parent.ownerDocument.createRange();range.setStartBefore(get(children[start],-1));range.setEndAfter(get(children[end-1],-1));range.deleteContents()}};const DELETION=-1;const INSERTION=1;const SKIP=0;const SKIP_OND=50;const HS=(futureNodes,futureStart,futureEnd,futureChanges,currentNodes,currentStart,currentEnd,currentChanges)=>{let k=0;let minLen=futureChanges<currentChanges?futureChanges:currentChanges;const link=Array(minLen++);const tresh=Array(minLen);tresh[0]=-1;for(let i=1;i<minLen;i++)tresh[i]=currentEnd;const keymap=new Map$1;for(let i=currentStart;i<currentEnd;i++)keymap.set(currentNodes[i],i);for(let i=futureStart;i<futureEnd;i++){const idxInOld=keymap.get(futureNodes[i]);if(idxInOld!=null){k=findK(tresh,minLen,idxInOld);if(-1<k){tresh[k]=idxInOld;link[k]={newi:i,oldi:idxInOld,prev:link[k-1]}}}}k=--minLen;--currentEnd;while(tresh[k]>currentEnd)--k;minLen=currentChanges+futureChanges-k;const diff=Array(minLen);let ptr=link[k];--futureEnd;while(ptr){const{newi:newi,oldi:oldi}=ptr;while(futureEnd>newi){diff[--minLen]=INSERTION;--futureEnd}while(currentEnd>oldi){diff[--minLen]=DELETION;--currentEnd}diff[--minLen]=SKIP;--futureEnd;--currentEnd;ptr=ptr.prev}while(futureEnd>=futureStart){diff[--minLen]=INSERTION;--futureEnd}while(currentEnd>=currentStart){diff[--minLen]=DELETION;--currentEnd}return diff};const OND=(futureNodes,futureStart,rows,currentNodes,currentStart,cols,compare)=>{const length=rows+cols;const v=[];let d,k,r,c,pv,cv,pd;outer:for(d=0;d<=length;d++){if(d>SKIP_OND)return null;pd=d-1;pv=d?v[d-1]:[0,0];cv=v[d]=[];for(k=-d;k<=d;k+=2){if(k===-d||k!==d&&pv[pd+k-1]<pv[pd+k+1]){c=pv[pd+k+1]}else{c=pv[pd+k-1]+1}r=c-k;while(c<cols&&r<rows&&compare(currentNodes[currentStart+c],futureNodes[futureStart+r])){c++;r++}if(c===cols&&r===rows){break outer}cv[d+k]=c}}const diff=Array(d/2+length/2);let diffIdx=diff.length-1;for(d=v.length-1;d>=0;d--){while(c>0&&r>0&&compare(currentNodes[currentStart+c-1],futureNodes[futureStart+r-1])){diff[diffIdx--]=SKIP;c--;r--}if(!d)break;pd=d-1;pv=d?v[d-1]:[0,0];k=c-r;if(k===-d||k!==d&&pv[pd+k-1]<pv[pd+k+1]){r--;diff[diffIdx--]=INSERTION}else{c--;diff[diffIdx--]=DELETION}}return diff};const applyDiff=(diff,get,parentNode,futureNodes,futureStart,currentNodes,currentStart,currentLength,before)=>{const live=new Map$1;const length=diff.length;let currentIndex=currentStart;let i=0;while(i<length){switch(diff[i++]){case SKIP:futureStart++;currentIndex++;break;case INSERTION:live.set(futureNodes[futureStart],1);append(get,parentNode,futureNodes,futureStart++,futureStart,currentIndex<currentLength?get(currentNodes[currentIndex],0):before);break;case DELETION:currentIndex++;break}}i=0;while(i<length){switch(diff[i++]){case SKIP:currentStart++;break;case DELETION:if(live.has(currentNodes[currentStart]))currentStart++;else remove(get,parentNode,currentNodes,currentStart++,currentStart);break}}};const findK=(ktr,length,j)=>{let lo=1;let hi=length;while(lo<hi){const mid=(lo+hi)/2>>>0;if(j<ktr[mid])hi=mid;else lo=mid+1}return lo};const smartDiff=(get,parentNode,futureNodes,futureStart,futureEnd,futureChanges,currentNodes,currentStart,currentEnd,currentChanges,currentLength,compare,before)=>{applyDiff(OND(futureNodes,futureStart,futureChanges,currentNodes,currentStart,currentChanges,compare)||HS(futureNodes,futureStart,futureEnd,futureChanges,currentNodes,currentStart,currentEnd,currentChanges),get,parentNode,futureNodes,futureStart,currentNodes,currentStart,currentLength,before)};const domdiff=(parentNode,currentNodes,futureNodes,options)=>{if(!options)options={};const compare=options.compare||eqeq;const get=options.node||identity;const before=options.before==null?null:get(options.before,0);const currentLength=currentNodes.length;let currentEnd=currentLength;let currentStart=0;let futureEnd=futureNodes.length;let futureStart=0;while(currentStart<currentEnd&&futureStart<futureEnd&&compare(currentNodes[currentStart],futureNodes[futureStart])){currentStart++;futureStart++}while(currentStart<currentEnd&&futureStart<futureEnd&&compare(currentNodes[currentEnd-1],futureNodes[futureEnd-1])){currentEnd--;futureEnd--}const currentSame=currentStart===currentEnd;const futureSame=futureStart===futureEnd;if(currentSame&&futureSame)return futureNodes;if(currentSame&&futureStart<futureEnd){append(get,parentNode,futureNodes,futureStart,futureEnd,next(get,currentNodes,currentStart,currentLength,before));return futureNodes}if(futureSame&&currentStart<currentEnd){remove(get,parentNode,currentNodes,currentStart,currentEnd);return futureNodes}const currentChanges=currentEnd-currentStart;const futureChanges=futureEnd-futureStart;let i=-1;if(currentChanges<futureChanges){i=indexOf(futureNodes,futureStart,futureEnd,currentNodes,currentStart,currentEnd,compare);if(-1<i){append(get,parentNode,futureNodes,futureStart,i,get(currentNodes[currentStart],0));append(get,parentNode,futureNodes,i+currentChanges,futureEnd,next(get,currentNodes,currentEnd,currentLength,before));return futureNodes}}else if(futureChanges<currentChanges){i=indexOf(currentNodes,currentStart,currentEnd,futureNodes,futureStart,futureEnd,compare);if(-1<i){remove(get,parentNode,currentNodes,currentStart,i);remove(get,parentNode,currentNodes,i+futureChanges,currentEnd);return futureNodes}}if(currentChanges<2||futureChanges<2){append(get,parentNode,futureNodes,futureStart,futureEnd,get(currentNodes[currentStart],0));remove(get,parentNode,currentNodes,currentStart,currentEnd);return futureNodes}if(currentChanges===futureChanges&&isReversed(futureNodes,futureEnd,currentNodes,currentStart,currentEnd,compare)){append(get,parentNode,futureNodes,futureStart,futureEnd,next(get,currentNodes,currentEnd,currentLength,before));return futureNodes}smartDiff(get,parentNode,futureNodes,futureStart,futureEnd,futureChanges,currentNodes,currentStart,currentEnd,currentChanges,currentLength,compare,before);return futureNodes};var self$3=undefined||{};self$3.CustomEvent=typeof CustomEvent==="function"?CustomEvent:function(__p__){CustomEvent[__p__]=new CustomEvent("").constructor[__p__];return CustomEvent;function CustomEvent(type,init){if(!init)init={};var e=document.createEvent("CustomEvent");e.initCustomEvent(type,!!init.bubbles,!!init.cancelable,init.detail);return e}}("prototype");var CustomEvent$1=self$3.CustomEvent;function Component(){return this}function setup(content){const children=new WeakMap$1;const create=Object.create;const createEntry=(wm,id,component)=>{wm.set(id,component);return component};const get=(Class,info,context,id)=>{const relation=info.get(Class)||relate(Class,info);switch(typeof id){case"object":case"function":const wm=relation.w||(relation.w=new WeakMap$1);return wm.get(id)||createEntry(wm,id,new Class(context));default:const sm=relation.p||(relation.p=create(null));return sm[id]||(sm[id]=new Class(context))}};const relate=(Class,info)=>{const relation={w:null,p:null};info.set(Class,relation);return relation};const set=context=>{const info=new Map$1;children.set(context,info);return info};Object.defineProperties(Component,{for:{configurable:true,value(context,id){return get(this,children.get(context)||set(context),context,id==null?"default":id)}}});Object.defineProperties(Component.prototype,{handleEvent:{value(e){const ct=e.currentTarget;this["getAttribute"in ct&&ct.getAttribute("data-call")||"on"+e.type](e)}},html:lazyGetter("html",content),svg:lazyGetter("svg",content),state:lazyGetter("state",function(){return this.defaultState}),defaultState:{get(){return{}}},dispatch:{value(type,detail){const{_wire$:_wire$}=this;if(_wire$){const event=new CustomEvent$1(type,{bubbles:true,cancelable:true,detail:detail});event.component=this;return(_wire$.dispatchEvent?_wire$:_wire$.firstChild).dispatchEvent(event)}return false}},setState:{value(state,render){const target=this.state;const source=typeof state==="function"?state.call(this,target):state;for(const key in source)target[key]=source[key];if(render!==false)this.render();return this}}})}const lazyGetter=(type,fn)=>{const secret="_"+type+"$";return{get(){return this[secret]||setValue(this,secret,fn.call(this,type))},set(value){setValue(this,secret,value)}}};const setValue=(self,secret,value)=>Object.defineProperty(self,secret,{configurable:true,value:typeof value==="function"?function(){return self._wire$=value.apply(this,arguments)}:value})[secret];Object.defineProperties(Component.prototype,{ELEMENT_NODE:{value:1},nodeType:{value:-1}});const attributes={};const intents={};const keys=[];const hasOwnProperty=intents.hasOwnProperty;let length=0;var Intent={attributes:attributes,define:(intent,callback)=>{if(intent.indexOf("-")<0){if(!(intent in intents)){length=keys.push(intent)}intents[intent]=callback}else{attributes[intent]=callback}},invoke:(object,callback)=>{for(let i=0;i<length;i++){let key=keys[i];if(hasOwnProperty.call(object,key)){return intents[key](object[key],callback)}}}};var isArray=Array.isArray||function(toString){var $=toString.call([]);return function isArray(object){return toString.call(object)===$}}({}.toString);var createContent=function(document){var FRAGMENT="fragment";var TEMPLATE="template";var HAS_CONTENT="content"in create(TEMPLATE);var createHTML=HAS_CONTENT?function(html){var template=create(TEMPLATE);template.innerHTML=html;return template.content}:function(html){var content=create(FRAGMENT);var template=create(TEMPLATE);var childNodes=null;if(/^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html)){var selector=RegExp.$1;template.innerHTML="<table>"+html+"</table>";childNodes=template.querySelectorAll(selector)}else{template.innerHTML=html;childNodes=template.childNodes}append(content,childNodes);return content};return function createContent(markup,type){return(type==="svg"?createSVG:createHTML)(markup)};function append(root,childNodes){var length=childNodes.length;while(length--)root.appendChild(childNodes[0])}function create(element){return element===FRAGMENT?document.createDocumentFragment():document.createElementNS("http://www.w3.org/1999/xhtml",element)}function createSVG(svg){var content=create(FRAGMENT);var template=create("div");template.innerHTML='<svg xmlns="http://www.w3.org/2000/svg">'+svg+"</svg>";append(content,template.firstChild.childNodes);return content}}(document);function disconnected(poly){var Event=poly.Event;var WeakSet=poly.WeakSet;var notObserving=true;var observer=null;return function observe(node){if(notObserving){notObserving=!notObserving;observer=new WeakSet;startObserving(node.ownerDocument)}observer.add(node);return node};function startObserving(document){var connected=new WeakSet;var disconnected=new WeakSet;try{new MutationObserver(changes).observe(document,{subtree:true,childList:true})}catch(o_O){var timer=0;var records=[];var reschedule=function(record){records.push(record);clearTimeout(timer);timer=setTimeout(function(){changes(records.splice(timer=0,records.length))},0)};document.addEventListener("DOMNodeRemoved",function(event){reschedule({addedNodes:[],removedNodes:[event.target]})},true);document.addEventListener("DOMNodeInserted",function(event){reschedule({addedNodes:[event.target],removedNodes:[]})},true)}function changes(records){for(var record,length=records.length,i=0;i<length;i++){record=records[i];dispatchAll(record.removedNodes,"disconnected",disconnected,connected);dispatchAll(record.addedNodes,"connected",connected,disconnected)}}function dispatchAll(nodes,type,wsin,wsout){for(var node,event=new Event(type),length=nodes.length,i=0;i<length;(node=nodes[i++]).nodeType===1&&dispatchTarget(node,event,type,wsin,wsout));}function dispatchTarget(node,event,type,wsin,wsout){if(observer.has(node)&&!wsin.has(node)){wsout.delete(node);wsin.add(node);node.dispatchEvent(event)}for(var children=node.children||[],length=children.length,i=0;i<length;dispatchTarget(children[i++],event,type,wsin,wsout));}}}var importNode=function(document,appendChild,cloneNode,createTextNode,importNode){var native=importNode in document;var fragment=document.createDocumentFragment();fragment[appendChild](document[createTextNode]("g"));fragment[appendChild](document[createTextNode](""));var content=native?document[importNode](fragment,true):fragment[cloneNode](true);return content.childNodes.length<2?function importNode(node,deep){var clone=node[cloneNode]();for(var childNodes=node.childNodes||[],length=childNodes.length,i=0;deep&&i<length;i++){clone[appendChild](importNode(childNodes[i],deep))}return clone}:native?document[importNode]:function(node,deep){return node[cloneNode](!!deep)}}(document,"appendChild","cloneNode","createTextNode","importNode");var trim="".trim||function(){return String(this).replace(/^\s+|\s+/g,"")};var UID="-"+Math.random().toFixed(6)+"%";var UID_IE=false;try{if(!function(template,content,tabindex){return content in template&&(template.innerHTML="<p "+tabindex+'="'+UID+'"></p>',template[content].childNodes[0].getAttribute(tabindex)==UID)}(document.createElement("template"),"content","tabindex")){UID="_dt: "+UID.slice(1,-1)+";";UID_IE=true}}catch(meh){}var UIDC="\x3c!--"+UID+"--\x3e";var COMMENT_NODE=8;var ELEMENT_NODE=1;var TEXT_NODE=3;var SHOULD_USE_TEXT_CONTENT=/^(?:style|textarea)$/i;var VOID_ELEMENTS=/^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;function sanitize(template){return template.join(UIDC).replace(selfClosing,fullClosing).replace(attrSeeker,attrReplacer)}var spaces=" \\f\\n\\r\\t";var almostEverything="[^"+spaces+"\\/>\"'=]+";var attrName="["+spaces+"]+"+almostEverything;var tagName="<([A-Za-z]+[A-Za-z0-9:._-]*)((?:";var attrPartials="(?:\\s*=\\s*(?:'[^']*?'|\"[^\"]*?\"|<[^>]*?>|"+almostEverything.replace("\\/","")+"))?)";var attrSeeker=new RegExp(tagName+attrName+attrPartials+"+)(["+spaces+"]*/?>)","g");var selfClosing=new RegExp(tagName+attrName+attrPartials+"*)(["+spaces+"]*/>)","g");var findAttributes=new RegExp("("+attrName+"\\s*=\\s*)(['\"]?)"+UIDC+"\\2","gi");function attrReplacer($0,$1,$2,$3){return"<"+$1+$2.replace(findAttributes,replaceAttributes)+$3}function replaceAttributes($0,$1,$2){return $1+($2||'"')+UID+($2||'"')}function fullClosing($0,$1,$2){return VOID_ELEMENTS.test($1)?$0:"<"+$1+$2+"></"+$1+">"}function find(node,path){var length=path.length;var i=0;while(i<length)node=node.childNodes[path[i++]];return node}function parse(node,holes,parts,path){var childNodes=node.childNodes;var length=childNodes.length;var i=0;while(i<length){var child=childNodes[i];switch(child.nodeType){case ELEMENT_NODE:var childPath=path.concat(i);parseAttributes(child,holes,parts,childPath);parse(child,holes,parts,childPath);break;case COMMENT_NODE:var textContent=child.textContent;if(textContent===UID){parts.shift();holes.push(SHOULD_USE_TEXT_CONTENT.test(node.nodeName)?Text(node,path):Any(child,path.concat(i)))}else{switch(textContent.slice(0,2)){case"/*":if(textContent.slice(-2)!=="*/")break;case"ðŸ‘»":node.removeChild(child);i--;length--}}break;case TEXT_NODE:if(SHOULD_USE_TEXT_CONTENT.test(node.nodeName)&&trim.call(child.textContent)===UIDC){parts.shift();holes.push(Text(node,path))}break}i++}}function parseAttributes(node,holes,parts,path){var cache=new Map$1;var attributes=node.attributes;var remove=[];var array=remove.slice.call(attributes,0);var length=array.length;var i=0;while(i<length){var attribute=array[i++];var direct=attribute.value===UID;var sparse;if(direct||1<(sparse=attribute.value.split(UIDC)).length){var name=attribute.name;if(!cache.has(name)){var realName=parts.shift().replace(direct?/^(?:|[\S\s]*?\s)(\S+?)\s*=\s*('|")?$/:new RegExp("^(?:|[\\S\\s]*?\\s)("+name+")\\s*=\\s*('|\")","i"),"$1");var value=attributes[realName]||attributes[realName.toLowerCase()];cache.set(name,value);if(direct)holes.push(Attr(value,path,realName,null));else{var skip=sparse.length-2;while(skip--)parts.shift();holes.push(Attr(value,path,realName,sparse))}}remove.push(attribute)}}length=remove.length;i=0;while(i<length){var attr=remove[i++];if(/^id$/i.test(attr.name))node.removeAttribute(attr.name);else node.removeAttributeNode(attr)}var nodeName=node.nodeName;if(/^script$/i.test(nodeName)){var script=document.createElement(nodeName);length=attributes.length;i=0;while(i<length)script.setAttributeNode(attributes[i++].cloneNode(true));script.textContent=node.textContent;node.parentNode.replaceChild(script,node)}}function Any(node,path){return{type:"any",node:node,path:path}}function Attr(node,path,name,sparse){return{type:"attr",node:node,path:path,name:name,sparse:sparse}}function Text(node,path){return{type:"text",node:node,path:path}}var parsed=new WeakMap$1;var referenced=new WeakMap$1;function createInfo(options,template){var markup=sanitize(template);var transform=options.transform;if(transform)markup=transform(markup);var content=createContent(markup,options.type);cleanContent(content);var holes=[];parse(content,holes,template.slice(0),[]);var info={content:content,updates:function(content){var updates=[];var len=holes.length;var i=0;var off=0;while(i<len){var info=holes[i++];var node=find(content,info.path);switch(info.type){case"any":updates.push({fn:options.any(node,[]),sparse:false});break;case"attr":var sparse=info.sparse;var fn=options.attribute(node,info.name,info.node);if(sparse===null)updates.push({fn:fn,sparse:false});else{off+=sparse.length-2;updates.push({fn:fn,sparse:true,values:sparse})}break;case"text":updates.push({fn:options.text(node),sparse:false});node.textContent="";break}}len+=off;return function(){var length=arguments.length;if(len!==length-1){throw new Error(length-1+" values instead of "+len+"\n"+template.join("${value}"))}var i=1;var off=1;while(i<length){var update=updates[i-off];if(update.sparse){var values=update.values;var value=values[0];var j=1;var l=values.length;off+=l-2;while(j<l)value+=arguments[i++]+values[j++];update.fn(value)}else update.fn(arguments[i++])}return content}}};parsed.set(template,info);return info}function createDetails(options,template){var info=parsed.get(template)||createInfo(options,template);var content=importNode.call(document,info.content,true);var details={content:content,template:template,updates:info.updates(content)};referenced.set(options,details);return details}function domtagger(options){return function(template){var details=referenced.get(options);if(details==null||details.template!==template)details=createDetails(options,template);details.updates.apply(null,arguments);return details.content}}function cleanContent(fragment){var childNodes=fragment.childNodes;var i=childNodes.length;while(i--){var child=childNodes[i];if(child.nodeType!==1&&trim.call(child.textContent).length===0){fragment.removeChild(child)}}}var hyperStyle=function(){var IS_NON_DIMENSIONAL=/acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;var hyphen=/([^A-Z])([A-Z]+)/g;return function hyperStyle(node,original){return"ownerSVGElement"in node?svg(node,original):update(node.style,false)};function ized($0,$1,$2){return $1+"-"+$2.toLowerCase()}function svg(node,original){var style;if(original)style=original.cloneNode(true);else{node.setAttribute("style","--hyper:style;");style=node.getAttributeNode("style")}style.value="";node.setAttributeNode(style);return update(style,true)}function toStyle(object){var key,css=[];for(key in object)css.push(key.replace(hyphen,ized),":",object[key],";");return css.join("")}function update(style,isSVG){var oldType,oldValue;return function(newValue){var info,key,styleValue,value;switch(typeof newValue){case"object":if(newValue){if(oldType==="object"){if(!isSVG){if(oldValue!==newValue){for(key in oldValue){if(!(key in newValue)){style[key]=""}}}}}else{if(isSVG)style.value="";else style.cssText=""}info=isSVG?{}:style;for(key in newValue){value=newValue[key];styleValue=typeof value==="number"&&!IS_NON_DIMENSIONAL.test(key)?value+"px":value;if(!isSVG&&/^--/.test(key))info.setProperty(key,styleValue);else info[key]=styleValue}oldType="object";if(isSVG)style.value=toStyle(oldValue=info);else oldValue=newValue;break}default:if(oldValue!=newValue){oldType="string";oldValue=newValue;if(isSVG)style.value=newValue||"";else style.cssText=newValue||""}break}}}}();var Wire=function(slice,proto){proto=Wire.prototype;proto.ELEMENT_NODE=1;proto.nodeType=111;proto.remove=function(keepFirst){var childNodes=this.childNodes;var first=this.firstChild;var last=this.lastChild;this._=null;if(keepFirst&&childNodes.length===2){last.parentNode.removeChild(last)}else{var range=this.ownerDocument.createRange();range.setStartBefore(keepFirst?childNodes[1]:first);range.setEndAfter(last);range.deleteContents()}return first};proto.valueOf=function(forceAppend){var fragment=this._;var noFragment=fragment==null;if(noFragment)fragment=this._=this.ownerDocument.createDocumentFragment();if(noFragment||forceAppend){for(var n=this.childNodes,i=0,l=n.length;i<l;i++)fragment.appendChild(n[i])}return fragment};return Wire;function Wire(childNodes){var nodes=this.childNodes=slice.call(childNodes,0);this.firstChild=nodes[0];this.lastChild=nodes[nodes.length-1];this.ownerDocument=nodes[0].ownerDocument;this._=null}}([].slice);const DOCUMENT_FRAGMENT_NODE=11;const OWNER_SVG_ELEMENT="ownerSVGElement";const CONNECTED="connected";const DISCONNECTED="dis"+CONNECTED;const componentType=Component.prototype.nodeType;const wireType=Wire.prototype.nodeType;const observe=disconnected({Event:CustomEvent$1,WeakSet:WeakSet$1});const asHTML=html=>({html:html});const asNode=(item,i)=>{switch(item.nodeType){case wireType:return 1/i<0?i?item.remove(true):item.lastChild:i?item.valueOf(true):item.firstChild;case componentType:return asNode(item.render(),i);default:return item}};const canDiff=value=>"ELEMENT_NODE"in value;const invokeAtDistance=(value,callback)=>{callback(value.placeholder);if("text"in value){Promise.resolve(value.text).then(String).then(callback)}else if("any"in value){Promise.resolve(value.any).then(callback)}else if("html"in value){Promise.resolve(value.html).then(asHTML).then(callback)}else{Promise.resolve(Intent.invoke(value,callback)).then(callback)}};const isPromise_ish=value=>value!=null&&"then"in value;const readOnly=/^(?:form|list)$/i;const slice=[].slice;const text=(node,text)=>node.ownerDocument.createTextNode(text);function Tagger(type){this.type=type;return domtagger(this)}Tagger.prototype={attribute(node,name,original){const isSVG=OWNER_SVG_ELEMENT in node;let oldValue;if(name==="style")return hyperStyle(node,original,isSVG);else if(/^on/.test(name)){let type=name.slice(2);if(type===CONNECTED||type===DISCONNECTED){observe(node)}else if(name.toLowerCase()in node){type=type.toLowerCase()}return newValue=>{if(oldValue!==newValue){if(oldValue)node.removeEventListener(type,oldValue,false);oldValue=newValue;if(newValue)node.addEventListener(type,newValue,false)}}}else if(name==="data"||!isSVG&&name in node&&!readOnly.test(name)){return newValue=>{if(oldValue!==newValue){oldValue=newValue;if(node[name]!==newValue&&newValue==null){node[name]="";node.removeAttribute(name)}else node[name]=newValue}}}else if(name in Intent.attributes){return any=>{const newValue=Intent.attributes[name](node,any);if(oldValue!==newValue){oldValue=newValue;if(newValue==null)node.removeAttribute(name);else node.setAttribute(name,newValue)}}}else{let owner=false;const attribute=original.cloneNode(true);return newValue=>{if(oldValue!==newValue){oldValue=newValue;if(attribute.value!==newValue){if(newValue==null){if(owner){owner=false;node.removeAttributeNode(attribute)}attribute.value=newValue}else{attribute.value=newValue;if(!owner){owner=true;node.setAttributeNode(attribute)}}}}}}},any(node,childNodes){const diffOptions={node:asNode,before:node};const nodeType=OWNER_SVG_ELEMENT in node?"svg":"html";let fastPath=false;let oldValue;const anyContent=value=>{switch(typeof value){case"string":case"number":case"boolean":if(fastPath){if(oldValue!==value){oldValue=value;childNodes[0].textContent=value}}else{fastPath=true;oldValue=value;childNodes=domdiff(node.parentNode,childNodes,[text(node,value)],diffOptions)}break;case"function":anyContent(value(node));break;case"object":case"undefined":if(value==null){fastPath=false;childNodes=domdiff(node.parentNode,childNodes,[],diffOptions);break}default:fastPath=false;oldValue=value;if(isArray(value)){if(value.length===0){if(childNodes.length){childNodes=domdiff(node.parentNode,childNodes,[],diffOptions)}}else{switch(typeof value[0]){case"string":case"number":case"boolean":anyContent({html:value});break;case"object":if(isArray(value[0])){value=value.concat.apply([],value)}if(isPromise_ish(value[0])){Promise.all(value).then(anyContent);break}default:childNodes=domdiff(node.parentNode,childNodes,value,diffOptions);break}}}else if(canDiff(value)){childNodes=domdiff(node.parentNode,childNodes,value.nodeType===DOCUMENT_FRAGMENT_NODE?slice.call(value.childNodes):[value],diffOptions)}else if(isPromise_ish(value)){value.then(anyContent)}else if("placeholder"in value){invokeAtDistance(value,anyContent)}else if("text"in value){anyContent(String(value.text))}else if("any"in value){anyContent(value.any)}else if("html"in value){childNodes=domdiff(node.parentNode,childNodes,slice.call(createContent([].concat(value.html).join(""),nodeType).childNodes),diffOptions)}else if("length"in value){anyContent(slice.call(value))}else{anyContent(Intent.invoke(value,anyContent))}break}};return anyContent},text(node){let oldValue;const textContent=value=>{if(oldValue!==value){oldValue=value;const type=typeof value;if(type==="object"&&value){if(isPromise_ish(value)){value.then(textContent)}else if("placeholder"in value){invokeAtDistance(value,textContent)}else if("text"in value){textContent(String(value.text))}else if("any"in value){textContent(value.any)}else if("html"in value){textContent([].concat(value.html).join(""))}else if("length"in value){textContent(slice.call(value).join(""))}else{textContent(Intent.invoke(value,textContent))}}else if(type==="function"){textContent(value(node))}else{node.textContent=value==null?"":value}}};return textContent}};var isNoOp=typeof document!=="object";var templateLiteral=function(tl){var RAW="raw";var isBroken=function(UA){return/(Firefox|Safari)\/(\d+)/.test(UA)&&!/(Chrom|Android)\/(\d+)/.test(UA)};var broken=isBroken((document.defaultView.navigator||{}).userAgent);var FTS=!(RAW in tl)||tl.propertyIsEnumerable(RAW)||!Object.isFrozen(tl[RAW]);if(broken||FTS){var forever={};var foreverCache=function(tl){for(var key=".",i=0;i<tl.length;i++)key+=tl[i].length+"."+tl[i];return forever[key]||(forever[key]=tl)};if(FTS)templateLiteral=foreverCache;else{var wm=new WeakMap$1;var set=function(tl,unique){wm.set(tl,unique);return unique};templateLiteral=function(tl){return wm.get(tl)||set(tl,foreverCache(tl))}}}else{isNoOp=true}return TL(tl)};function TL(tl){return isNoOp?tl:templateLiteral(tl)}function tta(template){var length=arguments.length;var args=[TL(template)];var i=1;while(i<length)args.push(arguments[i++]);return args}const wires=new WeakMap$1;const wire=(obj,type)=>obj==null?content(type||"html"):weakly(obj,type||"html");const content=type=>{let wire,tagger,template;return function(){const args=tta.apply(null,arguments);if(template!==args[0]){template=args[0];tagger=new Tagger(type);wire=wireContent(tagger.apply(tagger,args))}else{tagger.apply(tagger,args)}return wire}};const weakly=(obj,type)=>{const i=type.indexOf(":");let wire=wires.get(obj);let id=type;if(-1<i){id=type.slice(i+1);type=type.slice(0,i)||"html"}if(!wire)wires.set(obj,wire={});return wire[id]||(wire[id]=content(type))};const wireContent=node=>{const childNodes=node.childNodes;const{length:length}=childNodes;return length===1?childNodes[0]:length?new Wire(childNodes):node};const bewitched=new WeakMap$1;function render(){const wicked=bewitched.get(this);const args=tta.apply(null,arguments);if(wicked&&wicked.template===args[0]){wicked.tagger.apply(null,args)}else{upgrade.apply(this,args)}return this}function upgrade(template){const type=OWNER_SVG_ELEMENT in this?"svg":"html";const tagger=new Tagger(type);bewitched.set(this,{tagger:tagger,template:template});this.textContent="";this.appendChild(tagger.apply(null,arguments))}const bind=context=>render.bind(context);const define=Intent.define;const tagger=Tagger.prototype;hyper.Component=Component;hyper.bind=bind;hyper.define=define;hyper.diff=domdiff;hyper.hyper=hyper;hyper.observe=observe;hyper.tagger=tagger;hyper.wire=wire;hyper._={WeakMap:WeakMap$1,WeakSet:WeakSet$1};setup(content);function hyper(HTML){return arguments.length<2?HTML==null?content("html"):typeof HTML==="string"?hyper.wire(null,HTML):"raw"in HTML?content("html")(HTML):"nodeType"in HTML?hyper.bind(HTML):weakly(HTML,"html"):("raw"in HTML?content("html"):hyper.wire).apply(null,arguments)}const ATTRIBUTE_CHANGED_CALLBACK="attributeChangedCallback";const O=Object;const classes=[];const defineProperty=O.defineProperty;const getOwnPropertyDescriptor=O.getOwnPropertyDescriptor;const getOwnPropertyNames=O.getOwnPropertyNames;const getOwnPropertySymbols=O.getOwnPropertySymbols||(()=>[]);const getPrototypeOf=O.getPrototypeOf||(o=>o.__proto__);const ownKeys=typeof Reflect==="object"&&Reflect.ownKeys||(o=>getOwnPropertyNames(o).concat(getOwnPropertySymbols(o)));const setPrototypeOf=O.setPrototypeOf||((o,p)=>(o.__proto__=p,o));const camel=name=>name.replace(/-([a-z])/g,($0,$1)=>$1.toUpperCase());const{attachShadow:attachShadow}=HTMLElement.prototype;const sr=new WeakMap;class HyperHTMLElement extends HTMLElement{static define(name,options){const Class=this;const proto=Class.prototype;const onChanged=proto[ATTRIBUTE_CHANGED_CALLBACK];const hasChange=!!onChanged;const booleanAttributes=Class.booleanAttributes||[];booleanAttributes.forEach(name=>{if(!(name in proto))defineProperty(proto,camel(name),{configurable:true,get(){return this.hasAttribute(name)},set(value){if(!value||value==="false")this.removeAttribute(name);else this.setAttribute(name,value)}})});const observedAttributes=Class.observedAttributes||[];observedAttributes.forEach(name=>{if(!(name in proto))defineProperty(proto,camel(name),{configurable:true,get(){return this.getAttribute(name)},set(value){if(value==null)this.removeAttribute(name);else this.setAttribute(name,value)}})});const attributes=booleanAttributes.concat(observedAttributes);if(attributes.length)defineProperty(Class,"observedAttributes",{get(){return attributes}});const created=proto.created||function(){this.render()};defineProperty(proto,"_init$",{configurable:true,writable:true,value:true});defineProperty(proto,ATTRIBUTE_CHANGED_CALLBACK,{configurable:true,value:function aCC(name,prev,curr){if(this._init$){checkReady.call(this,created);if(this._init$)return this._init$$.push(aCC.bind(this,name,prev,curr))}if(hasChange&&prev!==curr){onChanged.apply(this,arguments)}}});const onConnected=proto.connectedCallback;const hasConnect=!!onConnected;defineProperty(proto,"connectedCallback",{configurable:true,value:function cC(){if(this._init$){checkReady.call(this,created);if(this._init$)return this._init$$.push(cC.bind(this))}if(hasConnect){onConnected.apply(this,arguments)}}});getOwnPropertyNames(proto).forEach(key=>{if(/^handle[A-Z]/.test(key)){const _key$="_"+key+"$";const method=proto[key];defineProperty(proto,key,{configurable:true,get(){return this[_key$]||(this[_key$]=method.bind(this))}})}});if(!("handleEvent"in proto)){defineProperty(proto,"handleEvent",{configurable:true,value(event){this[(event.currentTarget.dataset||{}).call||"on"+event.type](event)}})}if(options&&options.extends){const Native=document.createElement(options.extends).constructor;const Intermediate=class extends Native{};const Super=getPrototypeOf(Class);ownKeys(Super).filter(key=>["length","name","arguments","caller","prototype"].indexOf(key)<0).forEach(key=>defineProperty(Intermediate,key,getOwnPropertyDescriptor(Super,key)));ownKeys(Super.prototype).forEach(key=>defineProperty(Intermediate.prototype,key,getOwnPropertyDescriptor(Super.prototype,key)));setPrototypeOf(Class,Intermediate);setPrototypeOf(proto,Intermediate.prototype);customElements.define(name,Class,options)}else{customElements.define(name,Class)}classes.push(Class);return Class}attachShadow(){const shadowRoot=attachShadow.apply(this,arguments);sr.set(this,shadowRoot);return shadowRoot}get refs(){const value={};if("_html$"in this){const all=(sr.get(this)||this).querySelectorAll("[ref]");for(let{length:length}=all,i=0;i<length;i++){const node=all[i];value[node.getAttribute("ref")]=node}Object.defineProperty(this,"refs",{value:value});return value}return value}get html(){return this._html$||(this.html=bind(this.shadowRoot||this._shadowRoot||sr.get(this)||this))}set html(value){defineProperty(this,"_html$",{configurable:true,value:value})}render(){}get defaultState(){return{}}get state(){return this._state$||(this.state=this.defaultState)}set state(value){defineProperty(this,"_state$",{configurable:true,value:value})}setState(state,render){const target=this.state;const source=typeof state==="function"?state.call(this,target):state;for(const key in source)target[key]=source[key];if(render!==false)this.render();return this}}HyperHTMLElement.Component=Component;HyperHTMLElement.bind=bind;HyperHTMLElement.intent=define;HyperHTMLElement.wire=wire;HyperHTMLElement.hyper=hyper;try{if(Symbol.hasInstance)classes.push(defineProperty(HyperHTMLElement,Symbol.hasInstance,{enumerable:false,configurable:true,value(instance){return classes.some(isPrototypeOf,getPrototypeOf(instance))}}))}catch(meh){}const dom={type:"DOMContentLoaded",handleEvent(){if(dom.ready()){document.removeEventListener(dom.type,dom,false);dom.list.splice(0).forEach(invoke)}else setTimeout(dom.handleEvent)},ready(){return document.readyState==="complete"},list:[]};if(!dom.ready()){document.addEventListener(dom.type,dom,false)}function checkReady(created){if(dom.ready()||isReady.call(this,created)){if(this._init$){const list=this._init$$;if(list)delete this._init$$;created.call(defineProperty(this,"_init$",{value:false}));if(list)list.forEach(invoke)}}else{if(!this.hasOwnProperty("_init$$"))defineProperty(this,"_init$$",{configurable:true,value:[]});dom.list.push(checkReady.bind(this,created))}}function invoke(fn){fn()}function isPrototypeOf(Class){return this===Class.prototype}function isReady(created){let el=this;do{if(el.nextSibling)return true}while(el=el.parentNode);setTimeout(checkReady.bind(this,created));return false}let _length=100;function generateData(rows){const n=rows;const data=[];data[0]=[1];data[1]=[1,1];for(let row=2;row<n;row++){data[row]=[1];for(let col=1;col<=row-1;col++){const prevRow=data[row-1];data[row][col]=prevRow[col]+prevRow[col-1];data[row].push(1)}}return data}class PascalTriangle extends HyperHTMLElement{created(){this.attachShadow({mode:"open"});this._length=_length;this._list=generateData(_length);this._handleLoad=(e=>this.handleLoad(e));this.render()}handleLoad(e){this._length=parseInt(e.target.getAttribute("data-value"));this._list=generateData(this._length);this.render()}render(){return this.html`
<div>
    <button data-value="10" onclick=${this._handleLoad}>Load 10</button>
    <button data-value="100" onclick=${this._handleLoad}>Load 100</button>
    <button data-value="500" onclick=${this._handleLoad}>Load 500</button>
</div>
<div>
${this._list.map((line,y)=>HyperHTMLElement.wire(this,`:${y}`)`
    <div>${line.map((item,x)=>HyperHTMLElement.wire(this,`:${y}-${x}`)`
      <triangle-item text="${item}"/>`)}</div>`)}
</div>`}}PascalTriangle.define("pascal-triangle");class TriangleItem extends HyperHTMLElement{created(){this.text="";this.render()}static get observedAttributes(){return["text"]}attributeChangedCallback(name,oldValue,newValue){this[name]=newValue;this.render()}render(){return this.html`<span>${this.text}</span>`}}TriangleItem.define("triangle-item");