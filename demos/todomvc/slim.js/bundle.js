let alreadyExists=!1;try{const{Slim:e}=window;e&&e.plugins&&e.asap&&((console.error||console.warn||console.log)("Warning: slim.js already initialized on window"),alreadyExists=!0)}catch(e){}Symbol.Slim=Symbol("@SlimInternals");const _$=Symbol.Slim,isReadOnly=(e,t)=>{const i=Object.getOwnPropertyDescriptor(e,t);return i&&!1===i.writable},__flags={isIE11:!!window.MSInputMethodContext&&!!document.documentMode,isChrome:void 0,isEdge:void 0,isSafari:void 0,isFirefox:void 0};try{__flags.isChrome=/Chrome/.test(navigator.userAgent),__flags.isEdge=/Edge/.test(navigator.userAgent),__flags.isSafari=/Safari/.test(navigator.userAgent),__flags.isFirefox=/Firefox/.test(navigator.userAgent),(__flags.isIE11||__flags.isEdge)&&(__flags.isChrome=!1,Object.defineProperty(Node.prototype,"children",function(){return this.childNodes}))}catch(e){}class Internals{constructor(){this.boundParent=null,this.repeater={},this.bindings={},this.inbounds={},this.eventHandlers={},this.rootElement=null,this.createdCallbackInvoked=!1,this.sourceText=null,this.excluded=!1,this.autoBoundAttributes=[]}}class Slim extends HTMLElement{static get dashToCamel(){return e=>e.indexOf("-")<0?e:e.replace(/-[a-z]/g,e=>e[1].toUpperCase())}static get camelToDash(){return e=>e.replace(/([A-Z])/g,"-$1").toLowerCase()}static get rxProp(){return/(.+[^(\((.+)\))])/}static get rxMethod(){return/(.+)(\((.+)\)){1}/}static lookup(e,t,i){const n=t.split(".");let s;s=i&&i[_$].repeater[n[0]]?i[_$].repeater:e;let o=0;for(;s&&o<n.length;)s=s[n[o++]];return s}static _$(e){return e[_$]=e[_$]||new Internals,e[_$]}static tag(e,t,i){void 0===i?i=t:Object.defineProperty(i.prototype,"template",{value:t}),this.classToTagDict.set(i,e),customElements.define(e,i)}static tagOf(e){return this.classToTagDict.get(e)}static plugin(e,t){const i=this.plugins[e];if(!i)throw new Error(`Cannot attach plugin: ${e} is not a supported phase`);return i.add(t),()=>i.delete(t)}static checkCreationBlocking(e){if(e.attributes)for(let t=0,i=e.attributes.length;t<i;t++){const i=e.attributes[t];for(let[e,t]of Slim[_$].customDirectives)if(t.isBlocking&&e(i))return!0}return!1}static customDirective(e,t,i){if(this[_$].customDirectives.has(e))throw new Error(`Cannot register custom directive: ${e} already registered`);t.isBlocking=i,this[_$].customDirectives.set(e,t)}static executePlugins(e,t){this.plugins[e].forEach(e=>{e(t)})}static qSelectAll(e,t){return[...e.querySelectorAll(t)]}static unbind(e,t){const i=e[_$].bindings;Object.keys(i).forEach(e=>{const n=i[e].chain;n.has(t)&&n.delete(t)})}static root(e){return e.__isSlim&&e.useShadow?e[_$].rootElement||e:e}static removeChild(e){"function"==typeof e.remove&&e.remove(),e.parentNode&&e.parentNode.removeChild(e),this._$(e).internetExploderClone&&this.removeChild(this._$(e).internetExploderClone)}static wrapGetterSetter(e,t){const i=t.split(".")[0];let n=e.__lookupSetter__(i);if(n&&n[_$])return i;const s=e[i],{bindings:o}=this._$(e);o[i]={chain:new Set,value:s},o[i].value=s;const r=t=>{n&&n.call(e,t),o[i].value=t,e._executeBindings(i)};return r[_$]=!0,e.__defineGetter__(i,()=>e[_$].bindings[i].value),e.__defineSetter__(i,r),i}static bindOwn(e,t,i){return Slim.bind(e,e,t,i)}static bind(e,t,i,n){if(Slim._$(e),Slim._$(t),t[_$].excluded)return;n.source=e,n.target=t;const s=this.wrapGetterSetter(e,i);return t[_$].repeater[s]||e[_$].bindings[s].chain.add(t),t[_$].inbounds[s]=t[_$].inbounds[s]||new Set,t[_$].inbounds[s].add(n),function(){const t=e[_$].bindings;t[s]&&t[s].chain&&t[s].chain.delete(n)}}static update(e,...t){if(0===t.length)return Slim.commit(e);for(const i of t)Slim.commit(e,i)}static commit(e,t){let i=Slim._$(e);const n=t?[t]:Object.keys(i.bindings);for(const e of n){const t=i.inbounds[e];if(t)for(const e of t)e();const n=i.bindings[e];if(n){const t=n.chain;for(const i of t)Slim.commit(i,e)}}}constructor(){super(),Slim._$(this),this.__isSlim=!0;const e=()=>{Slim.checkCreationBlocking(this)||this.createdCallback()};__flags.isSafari?Slim.asap(e):e()}createdCallback(){this[_$]&&this[_$].createdCallbackInvoked||(this._initialize(),this[_$].createdCallbackInvoked=!0,this.onBeforeCreated(),Slim.executePlugins("create",this),this.render(),this.onCreated())}connectedCallback(){super.connectedCallback&&super.connectedCallback(),Slim.checkCreationBlocking(this)||this.createdCallback(),this.onAdded(),Slim.executePlugins("added",this)}disconnectedCallback(){this.onRemoved(),Slim.executePlugins("removed",this)}attributeChangedCallback(e,t,i){i!==t&&this.autoBoundAttributes.includes[e]&&(this[Slim.dashToCamel(e)]=i)}_executeBindings(e){Slim.debug("_executeBindings",this.localName,this),Slim.commit(this,e)}_bindChildren(e){Slim.debug("_bindChildren",this.localName),e||(e=Slim.qSelectAll(this,"*"));for(let t of e)if(Slim._$(t),t[_$].boundParent!==this){if(t[_$].boundParent=t[_$].boundParent||this,t.attributes.length){const e=Array.from(t.attributes);let i=0,n=t.attributes.length;for(;i<n;){const n=this,s=e[i];if(!t[_$].excluded)for(let[e,i]of Slim[_$].customDirectives){const o=e(s);o&&i(n,t,s,o)}i++}}t[_$].excluded||scanNode(this,t)}}_resetBindings(){Slim.debug("_resetBindings",this.localName),this[_$].bindings={}}_render(e){Slim.debug("_render",this.localName),Slim.executePlugins("beforeRender",this),this._resetBindings(),[...this.children].forEach(e=>{e.localName}),Slim.root(this).innerHTML="";const t=e||this.template,i=document.createElement("template");i.innerHTML=t;const n=i.content.cloneNode(!0),{externalStyle:s}=this[_$];s&&n.appendChild(this[_$]);const o=Slim.qSelectAll(n,"*"),r=()=>{(this[_$].rootElement||this).appendChild(n),this._bindChildren(o),this._executeBindings(),this.onRender(),Slim.executePlugins("afterRender",this)};this.useShadow?r():Slim.asap(r)}_initialize(){Slim.debug("_initialize",this.localName),this.useShadow?void 0===HTMLElement.prototype.attachShadow?this[_$].rootElement=this.createShadowRoot():this[_$].rootElement=this.attachShadow({mode:"open"}):this[_$].rootElement=this;const e=this.constructor.observedAttributes;e&&e.forEach(e=>{this[Slim.dashToCamel(e)]=this.getAttribute(e)})}get autoBoundAttributes(){return[]}commit(...e){Slim.commit(this,...e)}update(...e){Slim.update(this,...e)}render(e){this._render(e)}onRender(){}onBeforeCreated(){}onCreated(){}onAdded(){}onRemoved(){}find(e){return this[_$].rootElement.querySelector(e)}findAll(e){return Slim.qSelectAll(this[_$].rootElement,e)}callAttribute(e,t){const i=this.getAttribute(e);if(i)return this[_$].boundParent[i](t)}get useShadow(){return!1}get template(){return""}}Slim.classToTagDict=new Map,Slim.plugins={create:new Set,added:new Set,beforeRender:new Set,afterRender:new Set,removed:new Set},Slim.debug=(()=>{}),Slim.asap=window&&window.requestAnimationFrame?e=>window.requestAnimationFrame(e):"undefined"!=typeof setImmediate?setImmediate:e=>setTimeout(e,0),Slim[_$]={customDirectives:new Map,uniqueCounter:0,supportedNativeEvents:Object.keys(HTMLElement.prototype).filter(e=>e.startsWith("on"))},Slim.isReadOnly=isReadOnly,Slim.customDirective(e=>Slim[_$].supportedNativeEvents.indexOf(e.nodeName.slice(2)),(e,t,i)=>{const n=i.nodeName,s=i.value;Slim._$(t).eventHandlers=t[_$].eventHandlers||{};const o=t[_$].eventHandlers;o[n]=o[n]||new WeakSet;let r=i=>{try{e[s].call(e,i)}catch(i){i.message=`Could not respond to event "${n}" on ${t.localName} -> "${s}" on ${e.localName} ... ${i.message}`,console.warn(i)}};o[n].add(r),t.addEventListener(n,r),r=null});const scanNode=(e,t)=>{const i=Array.from(t.childNodes).filter(e=>e.nodeType===Node.TEXT_NODE),n=t,s=Slim._$(t).repeater;i.forEach(t=>{let i="";const o=t.nodeValue.match(/\{\{([^\}\}]+)+\}\}/g),r={},l={};if(o){Slim._$(t).sourceText=t.nodeValue,t[_$].repeater=s,o.forEach(t=>{const s=/\{\{(.+)(\((.+)\)){1}\}\}/.exec(t);if(s){const n=s[1],o=s[3].split(" ").join("").split(",");return o.map(e=>e.split(".")[0]).forEach(e=>r[e]=!0),void(l[t]=(s=>{const r=o.map(t=>Slim.lookup(e,t,s)),l=e[n],a=l?l.apply(e,r):void 0;void 0!==a&&(i=i.split(t).join(a||""))}))}const o=/\{\{(.+[^(\((.+)\))])\}\}/.exec(t);if(o){const s=o[1];r[s]=!0,l[t]=(o=>{const r=Slim.lookup(e,s,n);void 0!==r&&(i=i.split(t).join(r||""))})}});const a=()=>{i=t[_$].sourceText,Object.keys(l).forEach(e=>{l[e](t)}),t.nodeValue=i};Object.keys(r).forEach(t=>{Slim.bind(e,n,t,a)})}})};Slim.customDirective(e=>"s:id"===e.nodeName,(e,t,i)=>{Slim._$(t).boundParent[i.value]=t}),Slim.customDirective(e=>/^(bind):(\S+)/.exec(e.nodeName),(e,t,i,n)=>{const s=n[2],o=Slim.dashToCamel(s),r=i.value;const l=Slim.rxMethod.exec(r);if(l){const i=l[3].split(" ").join("").split(",");return void i.forEach(n=>{Slim.bind(e,t,n,()=>{const n=Slim.lookup(e,l[1],t),r=i.map(i=>Slim.lookup(e,i,t)),a=n.apply(e,r);void 0!==a&&(isReadOnly(t,o)||(t[o]=a),t.setAttribute(s,a))})})}const a=Slim.rxProp.exec(r);if(a){const i=a[1];Slim.bind(e,t,i,()=>{const i=Slim.lookup(e,r,t);void 0!==i&&(t.setAttribute(s,i),isReadOnly(t,o)||(t[o]=i))})}}),!alreadyExists&&window&&(window.Slim=Slim);!function(){const e=Symbol.Slim,{isReadOnly:t}=Slim;Slim.customDirective(e=>"s:repeat"===e.nodeName,(l,n,r)=>{let o=r.value,i="data";o.indexOf(" as ")>0&&([o,i]=o.split(" as "));let c=[];const a=document.createComment(`${n.localName} s:repeat="${r.value}"`),m=n.parentElement||Slim.root(l);m.insertBefore(a,n),n.removeAttribute("s:repeat"),Slim.qSelectAll(n,"*").forEach(e=>{Slim._$(e).excluded=!0}),Slim._$(n).excluded=!0;const s=n.outerHTML;n.remove();let S=[];const u=(e,t)=>{let l=t,n="";if(e<1)return n;for(;e>1;)1&e&&(n+=l),e>>=1,l+=l;return n+l};Slim.bind(l,a,o,()=>{const n=Slim.lookup(l,o)||[];let r;if(n.length<c.length&&(c.slice(n.length).forEach(t=>{Slim.unbind(l,t),t[e].subTree&&t[e].subTree.forEach(e=>Slim.unbind(l,e)),t.remove()}),c.length=n.length),n.length>c.length){const t=c.length,o=n.length-c.length,m=u(o,s),S=document.createRange();S.setStartBefore(a),r=S.createContextualFragment(m);for(let l=0;l<o;l++){const o=n[l+t],a=r.children[l];Slim._$(a).repeater[i]=o;const m=Slim.qSelectAll(a,"*");m.forEach(function(e){Slim._$(e).repeater[i]=o}),a[e].subTree=m,c.push(a)}const h=Slim.qSelectAll(r,"*");l._bindChildren(h)}const h=(e,l)=>{t(e,i)||(e[i]=l),Slim.commit(e,i)};n.forEach(function(t,l){if(S[l]!==t){const n=c[l];[n,...n[e].subTree||Slim.qSelectAll(n,"*")].forEach(l=>{l[e].repeater[i]=t,l[e].repeater.__node=n,l.__isSlim?(l.createdCallback(),Slim.asap(()=>h(l,t))):h(l,t)})}}),S=n.concat(),r&&Slim.asap(()=>{m.insertBefore(r,a)})})},!0)}();Slim.tag("todo-input",`\n    <style>\n        #new-todo-form {\n            position: relative;\n            font-size: 24px;\n            border-bottom: 1px solid #ededed;\n        }\n\n        #new-todo {\n            padding: 16px 16px 16px 60px;\n            border: none;\n            background: rgba(0, 0, 0, 0.003);\n            position: relative;\n            margin: 0;\n            width: 100%;\n            font-size: 24px;\n            font-family: inherit;\n            font-weight: inherit;\n            line-height: 1.4em;\n            border: 0;\n            outline: none;\n            color: inherit;\n            padding: 6px;\n            border: 1px solid #CCC;\n            box-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);\n            box-sizing: border-box;\n        }\n    </style>\n    <form id="new-todo-form">\n        <input id="new-todo" s:id="new_item_input" type="text" keydown="handleKeyDown" placeholder="What needs to be done?" />\n    </form>`,class TodoInput extends Slim{get useShadow(){return true}handleKeyDown(e){if(e.which===13){e.preventDefault();this.callAttribute("on-add",e.target.value);this.new_item_input.value="";this.new_item_input.blur()}}});Slim.tag("todo-item",`\n    <style>\n      :host {\n        display: block;\n      }\n\n      li.item {\n        font-size: 24px;\n        display: block;\n        position: relative;\n        border-bottom: 1px solid #ededed;\n      }\n\n      li.item input {\n        text-align: center;\n        width: 40px;\n        /* auto, since non-WebKit browsers doesn't support input styling */\n        height: auto;\n        position: absolute;\n        top: 9px;\n        bottom: 0;\n        margin: auto 0;\n        border: none;\n        /* Mobile Safari */\n        -webkit-appearance: none;\n        appearance: none;\n      }\n\n      li.item input:after {\n        content: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="-10 -18 100 135"><circle cx="50" cy="50" r="50" fill="none" stroke="#ededed" stroke-width="3"/></svg>');\n      }\n\n      li.item input:checked:after {\n        content: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="-10 -18 100 135"><circle cx="50" cy="50" r="50" fill="none" stroke="#bddad5" stroke-width="3"/><path fill="#5dc2af" d="M72 25L42 71 27 56l-4 4 20 20 34-52z"/></svg>');\n      }\n\n      li.item label {\n        white-space: pre;\n        word-break: break-word;\n        padding: 15px 60px 15px 15px;\n        margin-left: 45px;\n        display: block;\n        line-height: 1.2;\n        transition: color 0.4s;\n      }\n\n      li.item.completed label {\n        color: #d9d9d9;\n        text-decoration: line-through;\n      }\n\n      li.item button,\n      li.item input[type="checkbox"] {\n        outline: none;\n      }\n\n      li.item button {\n        margin: 0;\n        padding: 0;\n        border: 0;\n        background: none;\n        font-size: 100%;\n        vertical-align: baseline;\n        font-family: inherit;\n        font-weight: inherit;\n        color: inherit;\n        -webkit-appearance: none;\n        appearance: none;\n        -webkit-font-smoothing: antialiased;\n        -moz-font-smoothing: antialiased;\n        font-smoothing: antialiased;\n      }\n\n      li.item .destroy {\n        position: absolute;\n        top: 0;\n        right: 10px;\n        bottom: 0;\n        width: 40px;\n        height: 40px;\n        margin: auto 0;\n        font-size: 30px;\n        color: #cc9a9a;\n        margin-bottom: 11px;\n        transition: color 0.2s ease-out;\n      }\n\n      li.item .destroy:hover {\n        color: #af5b5e;\n      }\n    </style>\n    <li class="item">\n        <input type="checkbox" bind:checked="data.checked">\n        <label bind>{{data.text}}</label>\n        <button class="destroy" click="handleDeleteClick">x</button>\n    </li>`,class TodoItem extends Slim{get useShadow(){return true}handleDeleteClick(){this.callAttribute("on-remove",this.data.index)}});Slim.tag("my-todo",`\n    <style>\n        h1 {\n            font-size: 100px;\n            font-weight: 100;\n            text-align: center;\n            color: rgba(175, 47, 47, 0.15);\n        }\n\n        section {\n            background: #fff;\n            margin: 130px 0 40px 0;\n            position: relative;\n            box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.2), 0 25px 50px 0 rgba(0, 0, 0, 0.1);\n        }\n\n        #list-container {\n            margin: 0;\n            padding: 0;\n            list-style: none;\n            border-top: 1px solid #e6e6e6;\n        }\n    </style>\n    <h1>Todos Slim.js</h1>\n    <section>\n        <todo-input on-add="handleAdd"></todo-input>\n        <ul id="list-container">\n            <todo-item s:repeat="items" on-remove="handleRemove"></todo-item>\n        </ul>\n    </section>`,class MyTag extends Slim{get useShadow(){return true}onBeforeCreated(){this.items=[{text:"my initial todo",checked:false,index:0},{text:"Learn about Web Components",checked:true,index:1}]}handleAdd(text){this.items=[...this.items,{index:this.items.length,text:text}]}handleRemove(index){this.items=[...this.items.slice(0,index),...this.items.slice(index+1)]}});