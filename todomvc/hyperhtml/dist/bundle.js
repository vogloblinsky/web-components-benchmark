var self=undefined||{};try{self.WeakMap=WeakMap}catch(WeakMap){self.WeakMap=function(id,Object){var dP=Object.defineProperty;var hOP=Object.hasOwnProperty;var proto=WeakMap.prototype;proto.delete=function(key){return this.has(key)&&delete key[this._]};proto.get=function(key){return this.has(key)?key[this._]:void 0};proto.has=function(key){return hOP.call(key,this._)};proto.set=function(key,value){dP(key,this._,{configurable:true,value:value});return this};return WeakMap;function WeakMap(iterable){dP(this,"_",{value:"_@ungap/weakmap"+id++});if(iterable)iterable.forEach(add,this)}function add(pair){this.set(pair[0],pair[1])}}(Math.random(),Object)}var WeakMap$1=self.WeakMap;var self$1=undefined||{};try{self$1.WeakSet=WeakSet}catch(WeakSet){(function(id,dP){var proto=WeakSet.prototype;proto.add=function(object){if(!this.has(object))dP(object,this._,{value:true,configurable:true});return this};proto.has=function(object){return this.hasOwnProperty.call(object,this._)};proto.delete=function(object){return this.has(object)&&delete object[this._]};self$1.WeakSet=WeakSet;function WeakSet(){dP(this,"_",{value:"_@ungap/weakmap"+id++})}})(Math.random(),Object.defineProperty)}var WeakSet$1=self$1.WeakSet;var self$2=undefined||{};try{self$2.Map=Map}catch(Map){self$2.Map=function Map(){var i=0;var k=[];var v=[];return{delete:function(key){var had=contains(key);if(had){k.splice(i,1);v.splice(i,1)}return had},get:function get(key){return contains(key)?v[i]:void 0},has:function has(key){return contains(key)},set:function set(key,value){v[contains(key)?i:k.push(key)-1]=value;return this}};function contains(v){i=k.indexOf(v);return-1<i}}}var Map$1=self$2.Map;const append=(get,parent,children,start,end,before)=>{if(end-start<2)parent.insertBefore(get(children[start],1),before);else{const fragment=parent.ownerDocument.createDocumentFragment();while(start<end)fragment.appendChild(get(children[start++],1));parent.insertBefore(fragment,before)}};const eqeq=(a,b)=>a==b;const identity=O=>O;const indexOf=(moreNodes,moreStart,moreEnd,lessNodes,lessStart,lessEnd,compare)=>{const length=lessEnd-lessStart;if(length<1)return-1;while(moreEnd-moreStart>=length){let m=moreStart;let l=lessStart;while(m<moreEnd&&l<lessEnd&&compare(moreNodes[m],lessNodes[l])){m++;l++}if(l===lessEnd)return moreStart;moreStart=m+1}return-1};const isReversed=(futureNodes,futureEnd,currentNodes,currentStart,currentEnd,compare)=>{while(currentStart<currentEnd&&compare(currentNodes[currentStart],futureNodes[futureEnd-1])){currentStart++;futureEnd--}return futureEnd===0};const next=(get,list,i,length,before)=>i<length?get(list[i],0):0<i?get(list[i-1],-0).nextSibling:before;const remove=(get,parent,children,start,end)=>{if(end-start<2)parent.removeChild(get(children[start],-1));else{const range=parent.ownerDocument.createRange();range.setStartBefore(get(children[start],-1));range.setEndAfter(get(children[end-1],-1));range.deleteContents()}};const DELETION=-1;const INSERTION=1;const SKIP=0;const SKIP_OND=50;const HS=(futureNodes,futureStart,futureEnd,futureChanges,currentNodes,currentStart,currentEnd,currentChanges)=>{let k=0;let minLen=futureChanges<currentChanges?futureChanges:currentChanges;const link=Array(minLen++);const tresh=Array(minLen);tresh[0]=-1;for(let i=1;i<minLen;i++)tresh[i]=currentEnd;const keymap=new Map$1;for(let i=currentStart;i<currentEnd;i++)keymap.set(currentNodes[i],i);for(let i=futureStart;i<futureEnd;i++){const idxInOld=keymap.get(futureNodes[i]);if(idxInOld!=null){k=findK(tresh,minLen,idxInOld);if(-1<k){tresh[k]=idxInOld;link[k]={newi:i,oldi:idxInOld,prev:link[k-1]}}}}k=--minLen;--currentEnd;while(tresh[k]>currentEnd)--k;minLen=currentChanges+futureChanges-k;const diff=Array(minLen);let ptr=link[k];--futureEnd;while(ptr){const{newi:newi,oldi:oldi}=ptr;while(futureEnd>newi){diff[--minLen]=INSERTION;--futureEnd}while(currentEnd>oldi){diff[--minLen]=DELETION;--currentEnd}diff[--minLen]=SKIP;--futureEnd;--currentEnd;ptr=ptr.prev}while(futureEnd>=futureStart){diff[--minLen]=INSERTION;--futureEnd}while(currentEnd>=currentStart){diff[--minLen]=DELETION;--currentEnd}return diff};const OND=(futureNodes,futureStart,rows,currentNodes,currentStart,cols,compare)=>{const length=rows+cols;const v=[];let d,k,r,c,pv,cv,pd;outer:for(d=0;d<=length;d++){if(d>SKIP_OND)return null;pd=d-1;pv=d?v[d-1]:[0,0];cv=v[d]=[];for(k=-d;k<=d;k+=2){if(k===-d||k!==d&&pv[pd+k-1]<pv[pd+k+1]){c=pv[pd+k+1]}else{c=pv[pd+k-1]+1}r=c-k;while(c<cols&&r<rows&&compare(currentNodes[currentStart+c],futureNodes[futureStart+r])){c++;r++}if(c===cols&&r===rows){break outer}cv[d+k]=c}}const diff=Array(d/2+length/2);let diffIdx=diff.length-1;for(d=v.length-1;d>=0;d--){while(c>0&&r>0&&compare(currentNodes[currentStart+c-1],futureNodes[futureStart+r-1])){diff[diffIdx--]=SKIP;c--;r--}if(!d)break;pd=d-1;pv=d?v[d-1]:[0,0];k=c-r;if(k===-d||k!==d&&pv[pd+k-1]<pv[pd+k+1]){r--;diff[diffIdx--]=INSERTION}else{c--;diff[diffIdx--]=DELETION}}return diff};const applyDiff=(diff,get,parentNode,futureNodes,futureStart,currentNodes,currentStart,currentLength,before)=>{const live=new Map$1;const length=diff.length;let currentIndex=currentStart;let i=0;while(i<length){switch(diff[i++]){case SKIP:futureStart++;currentIndex++;break;case INSERTION:live.set(futureNodes[futureStart],1);append(get,parentNode,futureNodes,futureStart++,futureStart,currentIndex<currentLength?get(currentNodes[currentIndex],1):before);break;case DELETION:currentIndex++;break}}i=0;while(i<length){switch(diff[i++]){case SKIP:currentStart++;break;case DELETION:if(live.has(currentNodes[currentStart]))currentStart++;else remove(get,parentNode,currentNodes,currentStart++,currentStart);break}}};const findK=(ktr,length,j)=>{let lo=1;let hi=length;while(lo<hi){const mid=(lo+hi)/2>>>0;if(j<ktr[mid])hi=mid;else lo=mid+1}return lo};const smartDiff=(get,parentNode,futureNodes,futureStart,futureEnd,futureChanges,currentNodes,currentStart,currentEnd,currentChanges,currentLength,compare,before)=>{applyDiff(OND(futureNodes,futureStart,futureChanges,currentNodes,currentStart,currentChanges,compare)||HS(futureNodes,futureStart,futureEnd,futureChanges,currentNodes,currentStart,currentEnd,currentChanges),get,parentNode,futureNodes,futureStart,currentNodes,currentStart,currentLength,before)};const domdiff=(parentNode,currentNodes,futureNodes,options)=>{if(!options)options={};const compare=options.compare||eqeq;const get=options.node||identity;const before=options.before==null?null:get(options.before,0);const currentLength=currentNodes.length;let currentEnd=currentLength;let currentStart=0;let futureEnd=futureNodes.length;let futureStart=0;while(currentStart<currentEnd&&futureStart<futureEnd&&compare(currentNodes[currentStart],futureNodes[futureStart])){currentStart++;futureStart++}while(currentStart<currentEnd&&futureStart<futureEnd&&compare(currentNodes[currentEnd-1],futureNodes[futureEnd-1])){currentEnd--;futureEnd--}const currentSame=currentStart===currentEnd;const futureSame=futureStart===futureEnd;if(currentSame&&futureSame)return futureNodes;if(currentSame&&futureStart<futureEnd){append(get,parentNode,futureNodes,futureStart,futureEnd,next(get,currentNodes,currentStart,currentLength,before));return futureNodes}if(futureSame&&currentStart<currentEnd){remove(get,parentNode,currentNodes,currentStart,currentEnd);return futureNodes}const currentChanges=currentEnd-currentStart;const futureChanges=futureEnd-futureStart;let i=-1;if(currentChanges<futureChanges){i=indexOf(futureNodes,futureStart,futureEnd,currentNodes,currentStart,currentEnd,compare);if(-1<i){append(get,parentNode,futureNodes,futureStart,i,get(currentNodes[currentStart],0));append(get,parentNode,futureNodes,i+currentChanges,futureEnd,next(get,currentNodes,currentEnd,currentLength,before));return futureNodes}}else if(futureChanges<currentChanges){i=indexOf(currentNodes,currentStart,currentEnd,futureNodes,futureStart,futureEnd,compare);if(-1<i){remove(get,parentNode,currentNodes,currentStart,i);remove(get,parentNode,currentNodes,i+futureChanges,currentEnd);return futureNodes}}if(currentChanges<2||futureChanges<2){append(get,parentNode,futureNodes,futureStart,futureEnd,get(currentNodes[currentStart],0));remove(get,parentNode,currentNodes,currentStart,currentEnd);return futureNodes}if(currentChanges===futureChanges&&isReversed(futureNodes,futureEnd,currentNodes,currentStart,currentEnd,compare)){append(get,parentNode,futureNodes,futureStart,futureEnd,next(get,currentNodes,currentEnd,currentLength,before));return futureNodes}smartDiff(get,parentNode,futureNodes,futureStart,futureEnd,futureChanges,currentNodes,currentStart,currentEnd,currentChanges,currentLength,compare,before);return futureNodes};var self$3=undefined||{};self$3.CustomEvent=typeof CustomEvent==="function"?CustomEvent:function(__p__){CustomEvent[__p__]=new CustomEvent("").constructor[__p__];return CustomEvent;function CustomEvent(type,init){if(!init)init={};var e=document.createEvent("CustomEvent");e.initCustomEvent(type,!!init.bubbles,!!init.cancelable,init.detail);return e}}("prototype");var CustomEvent$1=self$3.CustomEvent;function Component(){return this}function setup(content){const children=new WeakMap$1;const create=Object.create;const createEntry=(wm,id,component)=>{wm.set(id,component);return component};const get=(Class,info,context,id)=>{const relation=info.get(Class)||relate(Class,info);switch(typeof id){case"object":case"function":const wm=relation.w||(relation.w=new WeakMap$1);return wm.get(id)||createEntry(wm,id,new Class(context));default:const sm=relation.p||(relation.p=create(null));return sm[id]||(sm[id]=new Class(context))}};const relate=(Class,info)=>{const relation={w:null,p:null};info.set(Class,relation);return relation};const set=context=>{const info=new Map$1;children.set(context,info);return info};Object.defineProperties(Component,{for:{configurable:true,value(context,id){return get(this,children.get(context)||set(context),context,id==null?"default":id)}}});Object.defineProperties(Component.prototype,{handleEvent:{value(e){const ct=e.currentTarget;this["getAttribute"in ct&&ct.getAttribute("data-call")||"on"+e.type](e)}},html:lazyGetter("html",content),svg:lazyGetter("svg",content),state:lazyGetter("state",function(){return this.defaultState}),defaultState:{get(){return{}}},dispatch:{value(type,detail){const{_wire$:_wire$}=this;if(_wire$){const event=new CustomEvent$1(type,{bubbles:true,cancelable:true,detail:detail});event.component=this;return(_wire$.dispatchEvent?_wire$:_wire$.childNodes[0]).dispatchEvent(event)}return false}},setState:{value(state,render){const target=this.state;const source=typeof state==="function"?state.call(this,target):state;for(const key in source)target[key]=source[key];if(render!==false)this.render();return this}}})}const lazyGetter=(type,fn)=>{const secret="_"+type+"$";return{get(){return this[secret]||setValue(this,secret,fn.call(this,type))},set(value){setValue(this,secret,value)}}};const setValue=(self,secret,value)=>Object.defineProperty(self,secret,{configurable:true,value:typeof value==="function"?function(){return self._wire$=value.apply(this,arguments)}:value})[secret];const attributes={};const intents={};const keys=[];const hasOwnProperty=intents.hasOwnProperty;let length=0;var Intent={attributes:attributes,define:(intent,callback)=>{if(intent.indexOf("-")<0){if(!(intent in intents)){length=keys.push(intent)}intents[intent]=callback}else{attributes[intent]=callback}},invoke:(object,callback)=>{for(let i=0;i<length;i++){let key=keys[i];if(hasOwnProperty.call(object,key)){return intents[key](object[key],callback)}}}};var isArray=Array.isArray||function(toString){var $=toString.call([]);return function isArray(object){return toString.call(object)===$}}({}.toString);var createContent=function(document){var FRAGMENT="fragment";var TEMPLATE="template";var HAS_CONTENT="content"in create(TEMPLATE);var createHTML=HAS_CONTENT?function(html){var template=create(TEMPLATE);template.innerHTML=html;return template.content}:function(html){var content=create(FRAGMENT);var template=create(TEMPLATE);var childNodes=null;if(/^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html)){var selector=RegExp.$1;template.innerHTML="<table>"+html+"</table>";childNodes=template.querySelectorAll(selector)}else{template.innerHTML=html;childNodes=template.childNodes}append(content,childNodes);return content};return function createContent(markup,type){return(type==="svg"?createSVG:createHTML)(markup)};function append(root,childNodes){var length=childNodes.length;while(length--)root.appendChild(childNodes[0])}function create(element){return element===FRAGMENT?document.createDocumentFragment():document.createElementNS("http://www.w3.org/1999/xhtml",element)}function createSVG(svg){var content=create(FRAGMENT);var template=create("div");template.innerHTML='<svg xmlns="http://www.w3.org/2000/svg">'+svg+"</svg>";append(content,template.firstChild.childNodes);return content}}(document);function disconnected(poly){var CONNECTED="connected";var DISCONNECTED="dis"+CONNECTED;var Event=poly.Event;var WeakSet=poly.WeakSet;var notObserving=true;var observer=new WeakSet;return function observe(node){if(notObserving){notObserving=!notObserving;startObserving(node.ownerDocument)}observer.add(node);return node};function startObserving(document){var dispatched=null;try{new MutationObserver(changes).observe(document,{subtree:true,childList:true})}catch(o_O){var timer=0;var records=[];var reschedule=function(record){records.push(record);clearTimeout(timer);timer=setTimeout(function(){changes(records.splice(timer=0,records.length))},0)};document.addEventListener("DOMNodeRemoved",function(event){reschedule({addedNodes:[],removedNodes:[event.target]})},true);document.addEventListener("DOMNodeInserted",function(event){reschedule({addedNodes:[event.target],removedNodes:[]})},true)}function changes(records){dispatched=new Tracker;for(var record,length=records.length,i=0;i<length;i++){record=records[i];dispatchAll(record.removedNodes,DISCONNECTED,CONNECTED);dispatchAll(record.addedNodes,CONNECTED,DISCONNECTED)}dispatched=null}function dispatchAll(nodes,type,counter){for(var node,event=new Event(type),length=nodes.length,i=0;i<length;(node=nodes[i++]).nodeType===1&&dispatchTarget(node,event,type,counter));}function dispatchTarget(node,event,type,counter){if(observer.has(node)&&!dispatched[type].has(node)){dispatched[counter].delete(node);dispatched[type].add(node);node.dispatchEvent(event)}for(var children=node.children||[],length=children.length,i=0;i<length;dispatchTarget(children[i++],event,type,counter));}function Tracker(){this[CONNECTED]=new WeakSet;this[DISCONNECTED]=new WeakSet}}}var importNode=function(document,appendChild,cloneNode,createTextNode,importNode){var native=importNode in document;var fragment=document.createDocumentFragment();fragment[appendChild](document[createTextNode]("g"));fragment[appendChild](document[createTextNode](""));var content=native?document[importNode](fragment,true):fragment[cloneNode](true);return content.childNodes.length<2?function importNode(node,deep){var clone=node[cloneNode]();for(var childNodes=node.childNodes||[],length=childNodes.length,i=0;deep&&i<length;i++){clone[appendChild](importNode(childNodes[i],deep))}return clone}:native?document[importNode]:function(node,deep){return node[cloneNode](!!deep)}}(document,"appendChild","cloneNode","createTextNode","importNode");var trim="".trim||function(){return String(this).replace(/^\s+|\s+/g,"")};var UID="-"+Math.random().toFixed(6)+"%";if(!function(template,content,tabindex){return content in template&&(template.innerHTML="<p "+tabindex+'="'+UID+'"></p>',template[content].childNodes[0].getAttribute(tabindex)==UID)}(document.createElement("template"),"content","tabindex")){UID="_dt: "+UID.slice(1,-1)+";"}var UIDC="\x3c!--"+UID+"--\x3e";var COMMENT_NODE=8;var ELEMENT_NODE=1;var TEXT_NODE=3;var SHOULD_USE_TEXT_CONTENT=/^(?:style|textarea)$/i;var VOID_ELEMENTS=/^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;function sanitize(template){return template.join(UIDC).replace(selfClosing,fullClosing).replace(attrSeeker,attrReplacer)}var spaces=" \\f\\n\\r\\t";var almostEverything="[^ "+spaces+"\\/>\"'=]+";var attrName="[ "+spaces+"]+"+almostEverything;var tagName="<([A-Za-z]+[A-Za-z0-9:_-]*)((?:";var attrPartials="(?:\\s*=\\s*(?:'[^']*?'|\"[^\"]*?\"|<[^>]*?>|"+almostEverything+"))?)";var attrSeeker=new RegExp(tagName+attrName+attrPartials+"+)([ "+spaces+"]*/?>)","g");var selfClosing=new RegExp(tagName+attrName+attrPartials+"*)([ "+spaces+"]*/>)","g");var findAttributes=new RegExp("("+attrName+"\\s*=\\s*)(['\"]?)"+UIDC+"\\2","gi");function attrReplacer($0,$1,$2,$3){return"<"+$1+$2.replace(findAttributes,replaceAttributes)+$3}function replaceAttributes($0,$1,$2){return $1+($2||'"')+UID+($2||'"')}function fullClosing($0,$1,$2){return VOID_ELEMENTS.test($1)?$0:"<"+$1+$2+"></"+$1+">"}function create(type,node,path,name){return{name:name,node:node,path:path,type:type}}function find(node,path){var length=path.length;var i=0;while(i<length)node=node.childNodes[path[i++]];return node}function parse(node,holes,parts,path){var childNodes=node.childNodes;var length=childNodes.length;var i=0;while(i<length){var child=childNodes[i];switch(child.nodeType){case ELEMENT_NODE:var childPath=path.concat(i);parseAttributes(child,holes,parts,childPath);parse(child,holes,parts,childPath);break;case COMMENT_NODE:if(child.textContent===UID){parts.shift();holes.push(SHOULD_USE_TEXT_CONTENT.test(node.nodeName)?create("text",node,path):create("any",child,path.concat(i)))}break;case TEXT_NODE:if(SHOULD_USE_TEXT_CONTENT.test(node.nodeName)&&trim.call(child.textContent)===UIDC){parts.shift();holes.push(create("text",node,path))}break}i++}}function parseAttributes(node,holes,parts,path){var cache=new Map$1;var attributes=node.attributes;var remove=[];var array=remove.slice.call(attributes,0);var length=array.length;var i=0;while(i<length){var attribute=array[i++];if(attribute.value===UID){var name=attribute.name;if(!cache.has(name)){var realName=parts.shift().replace(/^(?:|[\S\s]*?\s)(\S+?)\s*=\s*['"]?$/,"$1");var value=attributes[realName]||attributes[realName.toLowerCase()];cache.set(name,value);holes.push(create("attr",value,path,realName))}remove.push(attribute)}}length=remove.length;i=0;while(i<length){var attr=remove[i++];if(/^id$/i.test(attr.name))node.removeAttribute(attr.name);else node.removeAttributeNode(attr)}var nodeName=node.nodeName;if(/^script$/i.test(nodeName)){var script=document.createElement(nodeName);length=attributes.length;i=0;while(i<length)script.setAttributeNode(attributes[i++].cloneNode(true));script.textContent=node.textContent;node.parentNode.replaceChild(script,node)}}var parsed=new WeakMap$1;var referenced=new WeakMap$1;function createInfo(options,template){var markup=sanitize(template);var transform=options.transform;if(transform)markup=transform(markup);var content=createContent(markup,options.type);cleanContent(content);var holes=[];parse(content,holes,template.slice(0),[]);var info={content:content,updates:function(content){var callbacks=[];var len=holes.length;var i=0;while(i<len){var info=holes[i++];var node=find(content,info.path);switch(info.type){case"any":callbacks.push(options.any(node,[]));break;case"attr":callbacks.push(options.attribute(node,info.name,info.node));break;case"text":callbacks.push(options.text(node));node.textContent="";break}}return function(){var length=arguments.length;var values=length-1;var i=1;if(len!==values){throw new Error(values+" values instead of "+len+"\n"+template.join(", "))}while(i<length)callbacks[i-1](arguments[i++]);return content}}};parsed.set(template,info);return info}function createDetails(options,template){var info=parsed.get(template)||createInfo(options,template);var content=importNode.call(document,info.content,true);var details={content:content,template:template,updates:info.updates(content)};referenced.set(options,details);return details}function domtagger(options){return function(template){var details=referenced.get(options);if(details==null||details.template!==template)details=createDetails(options,template);details.updates.apply(null,arguments);return details.content}}function cleanContent(fragment){var childNodes=fragment.childNodes;var i=childNodes.length;while(i--){var child=childNodes[i];if(child.nodeType!==1&&trim.call(child.textContent).length===0){fragment.removeChild(child)}}}var hyperStyle=function(){var IS_NON_DIMENSIONAL=/acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;var hyphen=/([^A-Z])([A-Z]+)/g;return function hyperStyle(node,original){return"ownerSVGElement"in node?svg(node,original):update(node.style,false)};function ized($0,$1,$2){return $1+"-"+$2.toLowerCase()}function svg(node,original){var style;if(original)style=original.cloneNode(true);else{node.setAttribute("style","--hyper:style;");style=node.getAttributeNode("style")}style.value="";node.setAttributeNode(style);return update(style,true)}function toStyle(object){var key,css=[];for(key in object)css.push(key.replace(hyphen,ized),":",object[key],";");return css.join("")}function update(style,isSVG){var oldType,oldValue;return function(newValue){var info,key,styleValue,value;switch(typeof newValue){case"object":if(newValue){if(oldType==="object"){if(!isSVG){if(oldValue!==newValue){for(key in oldValue){if(!(key in newValue)){style[key]=""}}}}}else{if(isSVG)style.value="";else style.cssText=""}info=isSVG?{}:style;for(key in newValue){value=newValue[key];styleValue=typeof value==="number"&&!IS_NON_DIMENSIONAL.test(key)?value+"px":value;if(!isSVG&&/^--/.test(key))info.setProperty(key,styleValue);else info[key]=styleValue}oldType="object";if(isSVG)style.value=toStyle(oldValue=info);else oldValue=newValue;break}default:if(oldValue!=newValue){oldType="string";oldValue=newValue;if(isSVG)style.value=newValue||"";else style.cssText=newValue||""}break}}}}();const G=document.defaultView;const DOCUMENT_FRAGMENT_NODE$1=11;const OWNER_SVG_ELEMENT="ownerSVGElement";const CONNECTED="connected";const DISCONNECTED="dis"+CONNECTED;var templateLiteral=function(){var RAW="raw";var isNoOp=false;var templateLiteral=function(tl){if(!(RAW in tl)||tl.propertyIsEnumerable(RAW)||!Object.isFrozen(tl.raw)||/Firefox\/(\d+)/.test((document.defaultView.navigator||{}).userAgent)&&parseFloat(RegExp.$1)<55){var forever={};templateLiteral=function(tl){var key=RAW+tl.join(RAW);return forever[key]||(forever[key]=tl)};return templateLiteral(tl)}else{isNoOp=true;return tl}};return function(tl){return isNoOp?tl:templateLiteral(tl)}}();const doc=node=>node.ownerDocument||node;const fragment=node=>doc(node).createDocumentFragment();const text=(node,text)=>doc(node).createTextNode(text);const append$1="append"in fragment(document)?(node,childNodes)=>{node.append.apply(node,childNodes)}:(node,childNodes)=>{const length=childNodes.length;for(let i=0;i<length;i++){node.appendChild(childNodes[i])}};const reArguments=function(template){const args=[templateLiteral(template)];for(let i=1,length=arguments.length;i<length;i++)args[i]=arguments[i];return args};const slice=[].slice;function Wire(childNodes){this.childNodes=childNodes;this.length=childNodes.length;this.first=childNodes[0];this.last=childNodes[this.length-1];this._=null}Wire.prototype.valueOf=function valueOf(different){const noFragment=this._==null;if(noFragment)this._=fragment(this.first);if(noFragment||different)append$1(this._,this.childNodes);return this._};Wire.prototype.remove=function remove(){this._=null;const first=this.first;const last=this.last;if(this.length===2){last.parentNode.removeChild(last)}else{const range=doc(first).createRange();range.setStartBefore(this.childNodes[1]);range.setEndAfter(last);range.deleteContents()}return first};const observe=disconnected({Event:CustomEvent$1,WeakSet:WeakSet$1});const asHTML=html=>({html:html});const asNode=(item,i)=>{return"ELEMENT_NODE"in item?item:item.constructor===Wire?1/i<0?i?item.remove():item.last:i?item.valueOf(true):item.first:asNode(item.render(),i)};const canDiff=value=>"ELEMENT_NODE"in value||value instanceof Wire||value instanceof Component;const invokeAtDistance=(value,callback)=>{callback(value.placeholder);if("text"in value){Promise.resolve(value.text).then(String).then(callback)}else if("any"in value){Promise.resolve(value.any).then(callback)}else if("html"in value){Promise.resolve(value.html).then(asHTML).then(callback)}else{Promise.resolve(Intent.invoke(value,callback)).then(callback)}};const isPromise_ish=value=>value!=null&&"then"in value;const readOnly=/^(?:form|list)$/i;function Tagger(type){this.type=type;return domtagger(this)}Tagger.prototype={attribute(node,name,original){const isSVG=OWNER_SVG_ELEMENT in node;let oldValue;if(name==="style")return hyperStyle(node,original,isSVG);else if(/^on/.test(name)){let type=name.slice(2);if(type===CONNECTED||type===DISCONNECTED){observe(node)}else if(name.toLowerCase()in node){type=type.toLowerCase()}return newValue=>{if(oldValue!==newValue){if(oldValue)node.removeEventListener(type,oldValue,false);oldValue=newValue;if(newValue)node.addEventListener(type,newValue,false)}}}else if(name==="data"||!isSVG&&name in node&&!readOnly.test(name)){return newValue=>{if(oldValue!==newValue){oldValue=newValue;if(node[name]!==newValue){node[name]=newValue;if(newValue==null){node.removeAttribute(name)}}}}}else if(name in Intent.attributes){return any=>{oldValue=Intent.attributes[name](node,any);node.setAttribute(name,oldValue==null?"":oldValue)}}else{let owner=false;const attribute=original.cloneNode(true);return newValue=>{if(oldValue!==newValue){oldValue=newValue;if(attribute.value!==newValue){if(newValue==null){if(owner){owner=false;node.removeAttributeNode(attribute)}attribute.value=newValue}else{attribute.value=newValue;if(!owner){owner=true;node.setAttributeNode(attribute)}}}}}}},any(node,childNodes){const diffOptions={node:asNode,before:node};const nodeType=OWNER_SVG_ELEMENT in node?"svg":"html";let fastPath=false;let oldValue;const anyContent=value=>{switch(typeof value){case"string":case"number":case"boolean":if(fastPath){if(oldValue!==value){oldValue=value;childNodes[0].textContent=value}}else{fastPath=true;oldValue=value;childNodes=domdiff(node.parentNode,childNodes,[text(node,value)],diffOptions)}break;case"function":anyContent(value(node));break;case"object":case"undefined":if(value==null){fastPath=false;childNodes=domdiff(node.parentNode,childNodes,[],diffOptions);break}default:fastPath=false;oldValue=value;if(isArray(value)){if(value.length===0){if(childNodes.length){childNodes=domdiff(node.parentNode,childNodes,[],diffOptions)}}else{switch(typeof value[0]){case"string":case"number":case"boolean":anyContent({html:value});break;case"object":if(isArray(value[0])){value=value.concat.apply([],value)}if(isPromise_ish(value[0])){Promise.all(value).then(anyContent);break}default:childNodes=domdiff(node.parentNode,childNodes,value,diffOptions);break}}}else if(canDiff(value)){childNodes=domdiff(node.parentNode,childNodes,value.nodeType===DOCUMENT_FRAGMENT_NODE$1?slice.call(value.childNodes):[value],diffOptions)}else if(isPromise_ish(value)){value.then(anyContent)}else if("placeholder"in value){invokeAtDistance(value,anyContent)}else if("text"in value){anyContent(String(value.text))}else if("any"in value){anyContent(value.any)}else if("html"in value){childNodes=domdiff(node.parentNode,childNodes,slice.call(createContent([].concat(value.html).join(""),nodeType).childNodes),diffOptions)}else if("length"in value){anyContent(slice.call(value))}else{anyContent(Intent.invoke(value,anyContent))}break}};return anyContent},text(node){let oldValue;const textContent=value=>{if(oldValue!==value){oldValue=value;const type=typeof value;if(type==="object"&&value){if(isPromise_ish(value)){value.then(textContent)}else if("placeholder"in value){invokeAtDistance(value,textContent)}else if("text"in value){textContent(String(value.text))}else if("any"in value){textContent(value.any)}else if("html"in value){textContent([].concat(value.html).join(""))}else if("length"in value){textContent(slice.call(value).join(""))}else{textContent(Intent.invoke(value,textContent))}}else if(type==="function"){textContent(value(node))}else{node.textContent=value==null?"":value}}};return textContent}};const wires=new WeakMap$1;const wire=(obj,type)=>obj==null?content(type||"html"):weakly(obj,type||"html");const content=type=>{let wire,tagger,template;return function(){const args=reArguments.apply(null,arguments);if(template!==args[0]){template=args[0];tagger=new Tagger(type);wire=wireContent(tagger.apply(tagger,args))}else{tagger.apply(tagger,args)}return wire}};const weakly=(obj,type)=>{const i=type.indexOf(":");let wire=wires.get(obj);let id=type;if(-1<i){id=type.slice(i+1);type=type.slice(0,i)||"html"}if(!wire)wires.set(obj,wire={});return wire[id]||(wire[id]=content(type))};const wireContent=node=>{const childNodes=node.childNodes;return childNodes.length===1?childNodes[0]:new Wire(slice.call(childNodes,0))};const bewitched=new WeakMap$1;function render(){const wicked=bewitched.get(this);const args=reArguments.apply(null,arguments);if(wicked&&wicked.template===args[0]){wicked.tagger.apply(null,args)}else{upgrade.apply(this,args)}return this}function upgrade(){const args=reArguments.apply(null,arguments);const type=OWNER_SVG_ELEMENT in this?"svg":"html";const tagger=new Tagger(type);bewitched.set(this,{tagger:tagger,template:args[0]});this.textContent="";this.appendChild(tagger.apply(null,args))}const bind=context=>render.bind(context);const define=Intent.define;const tagger=Tagger.prototype;hyper.Component=Component;hyper.bind=bind;hyper.define=define;hyper.diff=domdiff;hyper.hyper=hyper;hyper.observe=observe;hyper.tagger=tagger;hyper.wire=wire;hyper._={global:G,WeakMap:WeakMap$1,WeakSet:WeakSet$1};setup(content);function hyper(HTML){return arguments.length<2?HTML==null?content("html"):typeof HTML==="string"?hyper.wire(null,HTML):"raw"in HTML?content("html")(HTML):"nodeType"in HTML?hyper.bind(HTML):weakly(HTML,"html"):("raw"in HTML?content("html"):hyper.wire).apply(null,arguments)}const ATTRIBUTE_CHANGED_CALLBACK="attributeChangedCallback";const O=Object;const classes=[];const defineProperty=O.defineProperty;const getOwnPropertyDescriptor=O.getOwnPropertyDescriptor;const getOwnPropertyNames=O.getOwnPropertyNames;const getOwnPropertySymbols=O.getOwnPropertySymbols||(()=>[]);const getPrototypeOf=O.getPrototypeOf||(o=>o.__proto__);const ownKeys=typeof Reflect==="object"&&Reflect.ownKeys||(o=>getOwnPropertyNames(o).concat(getOwnPropertySymbols(o)));const setPrototypeOf=O.setPrototypeOf||((o,p)=>(o.__proto__=p,o));const camel=name=>name.replace(/-([a-z])/g,($0,$1)=>$1.toUpperCase());class HyperHTMLElement extends HTMLElement{static define(name,options){const Class=this;const proto=Class.prototype;const onChanged=proto[ATTRIBUTE_CHANGED_CALLBACK];const hasChange=!!onChanged;const booleanAttributes=Class.booleanAttributes||[];booleanAttributes.forEach(name=>{if(!(name in proto))defineProperty(proto,camel(name),{configurable:true,get(){return this.hasAttribute(name)},set(value){if(!value||value==="false")this.removeAttribute(name);else this.setAttribute(name,value)}})});const observedAttributes=Class.observedAttributes||[];observedAttributes.forEach(name=>{if(!(name in proto))defineProperty(proto,camel(name),{configurable:true,get(){return this.getAttribute(name)},set(value){if(value==null)this.removeAttribute(name);else this.setAttribute(name,value)}})});const attributes=booleanAttributes.concat(observedAttributes);if(attributes.length)defineProperty(Class,"observedAttributes",{get(){return attributes}});const created=proto.created||function(){this.render()};defineProperty(proto,"_init$",{configurable:true,writable:true,value:true});defineProperty(proto,ATTRIBUTE_CHANGED_CALLBACK,{configurable:true,value:function aCC(name,prev,curr){if(this._init$){checkReady.call(this,created);if(this._init$)return this._init$$.push(aCC.bind(this,name,prev,curr))}if(hasChange&&prev!==curr){onChanged.apply(this,arguments)}}});const onConnected=proto.connectedCallback;const hasConnect=!!onConnected;defineProperty(proto,"connectedCallback",{configurable:true,value:function cC(){if(this._init$){checkReady.call(this,created);if(this._init$)return this._init$$.push(cC.bind(this))}if(hasConnect){onConnected.apply(this,arguments)}}});getOwnPropertyNames(proto).forEach(key=>{if(/^handle[A-Z]/.test(key)){const _key$="_"+key+"$";const method=proto[key];defineProperty(proto,key,{configurable:true,get(){return this[_key$]||(this[_key$]=method.bind(this))}})}});if(!("handleEvent"in proto)){defineProperty(proto,"handleEvent",{configurable:true,value(event){this[(event.currentTarget.dataset||{}).call||"on"+event.type](event)}})}if(options&&options.extends){const Native=document.createElement(options.extends).constructor;const Intermediate=class extends Native{};const Super=getPrototypeOf(Class);ownKeys(Super).filter(key=>["length","name","arguments","caller","prototype"].indexOf(key)<0).forEach(key=>defineProperty(Intermediate,key,getOwnPropertyDescriptor(Super,key)));ownKeys(Super.prototype).forEach(key=>defineProperty(Intermediate.prototype,key,getOwnPropertyDescriptor(Super.prototype,key)));setPrototypeOf(Class,Intermediate);setPrototypeOf(proto,Intermediate.prototype);customElements.define(name,Class,options)}else{customElements.define(name,Class)}classes.push(Class);return Class}get html(){return this._html$||(this.html=bind(this.shadowRoot||this._shadowRoot||this))}set html(value){defineProperty(this,"_html$",{configurable:true,value:value})}render(){}get defaultState(){return{}}get state(){return this._state$||(this.state=this.defaultState)}set state(value){defineProperty(this,"_state$",{configurable:true,value:value})}setState(state,render){const target=this.state;const source=typeof state==="function"?state.call(this,target):state;for(const key in source)target[key]=source[key];if(render!==false)this.render();return this}}HyperHTMLElement.Component=Component;HyperHTMLElement.bind=bind;HyperHTMLElement.intent=define;HyperHTMLElement.wire=wire;HyperHTMLElement.hyper=hyper;try{if(Symbol.hasInstance)classes.push(defineProperty(HyperHTMLElement,Symbol.hasInstance,{enumerable:false,configurable:true,value(instance){return classes.some(isPrototypeOf,getPrototypeOf(instance))}}))}catch(meh){}const dom={type:"DOMContentLoaded",handleEvent(){if(dom.ready()){document.removeEventListener(dom.type,dom,false);dom.list.splice(0).forEach(invoke)}else setTimeout(dom.handleEvent)},ready(){return document.readyState==="complete"},list:[]};if(!dom.ready()){document.addEventListener(dom.type,dom,false)}function checkReady(created){if(dom.ready()||isReady.call(this,created)){if(this._init$){const list=this._init$$;if(list)delete this._init$$;created.call(defineProperty(this,"_init$",{value:false}));if(list)list.forEach(invoke)}}else{if(!this.hasOwnProperty("_init$$"))defineProperty(this,"_init$$",{configurable:true,value:[]});dom.list.push(checkReady.bind(this,created))}}function invoke(fn){fn()}function isPrototypeOf(Class){return this===Class.prototype}function isReady(created){let el=this;do{if(el.nextSibling)return true}while(el=el.parentNode);setTimeout(checkReady.bind(this,created));return false}class MyTodo extends HyperHTMLElement{created(){this.attachShadow({mode:"open"});this._list=[{id:0,text:"my initial todo",checked:false},{id:1,text:"Learn about Web Components",checked:true}];this._addItem=(e=>this.addItem(e));this._removeItem=(e=>this.removeItem(e));this._toggleItem=(e=>this.toggleItem(e));this.render()}addItem(e){this._list=[...this._list,{id:this._list.length,text:e.detail,checked:false}];this.render()}removeItem(e){this._list.splice(e.detail,1);this.render()}toggleItem(e){const item=this._list[e.detail];this._list[e.detail]=Object.assign({},item,{checked:!item.checked});this.render()}render(){return this.html`
        <style>
        h1 {
            font-size: 100px;
            font-weight: 100;
            text-align: center;
            color: rgba(175, 47, 47, 0.15);
        }
        
        section {
            background: #fff;
            margin: 130px 0 40px 0;
            position: relative;
            box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.2), 0 25px 50px 0 rgba(0, 0, 0, 0.1);
        }
        
        #list-container {
            margin: 0;
            padding: 0;
            list-style: none;
            border-top: 1px solid #e6e6e6;
        }
        </style>
        <h1>Todos WC</h1>
        <section>
            <todo-input onsubmit=${this._addItem}></todo-input>
            <ul id="list-container">
            ${this._list.map((item,index)=>HyperHTMLElement.wire(item)`<todo-item index="${index}" 
                                                                                text="${item.text}" 
                                                                                checked="${item.checked}" 
                                                                                onremoved="${this._removeItem}"
                                                                                onchecked="${this._toggleItem}"></todo-item>`)}
            </ul>
        </section>
        `}}MyTodo.define("my-todo");class TodoInput extends HyperHTMLElement{created(){this.attachShadow({mode:"open"});this.state={value:""};this._handleSubmit=(e=>this.handleSubmit(e));this._handleInput=(e=>this.handleInput(e));this.render()}handleInput(e){this.state={value:e.target.value}}handleSubmit(e){e.preventDefault();if(!this.state.value)return;this.dispatchEvent(new CustomEvent("submit",{detail:this.state.value}));this.$input=this.shadowRoot.querySelector("#new-todo");this.$input.value="";this.$input.blur()}render(){return this.html`
        <style>
        #new-todo-form {
            position: relative;
            font-size: 24px;
            border-bottom: 1px solid #ededed;
        }

        #new-todo {
            padding: 16px 16px 16px 60px;
            border: none;
            background: rgba(0, 0, 0, 0.003);
            position: relative;
            margin: 0;
            width: 100%;
            font-size: 24px;
            font-family: inherit;
            font-weight: inherit;
            line-height: 1.4em;
            border: 0;
            outline: none;
            color: inherit;
            padding: 6px;
            border: 1px solid #CCC;
            box-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);
            box-sizing: border-box;
        }
    </style>
    <form id="new-todo-form" onsubmit=${this._handleSubmit}>
        <input id="new-todo" type="text" placeholder="What needs to be done?" oninput=${this._handleInput} value="${this.state.value}"/>
    </form>
        `}}TodoInput.define("todo-input");class TodoItem extends HyperHTMLElement{created(){this._handleOnChecked=(e=>this.handleOnChecked(e));this._handleOnRemoved=(e=>this.handleOnRemoved(e));this.render()}static get observedAttributes(){return["text","checked","index"]}attributeChangedCallback(name,oldValue,newValue){this[name]=newValue;this.render()}handleOnRemoved(e){this.dispatchEvent(new CustomEvent("removed",{detail:this.index,bubbles:true}))}handleOnChecked(e){this.dispatchEvent(new CustomEvent("checked",{detail:this.index,bubbles:true}))}render(){if(typeof this.text!=="string"||typeof this.checked!=="string"){return}return this.html`
        <style>
    :host {
        display: block;
    }

    li.item {
        font-size: 24px;
        display: block;
        position: relative;
        border-bottom: 1px solid #ededed;
    }

    li.item input {
        text-align: center;
        width: 40px;
        height: auto;
        position: absolute;
        top: 9px;
        bottom: 0;
        margin: auto 0;
        border: none;
        -webkit-appearance: none;
        appearance: none;
    }

    li.item input:after {
        content: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="-10 -18 100 135"><circle cx="50" cy="50" r="50" fill="none" stroke="#ededed" stroke-width="3"/></svg>');
    }

    li.item input:checked:after {
        content: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="-10 -18 100 135"><circle cx="50" cy="50" r="50" fill="none" stroke="#bddad5" stroke-width="3"/><path fill="#5dc2af" d="M72 25L42 71 27 56l-4 4 20 20 34-52z"/></svg>');
    }

    li.item label {
        white-space: pre;
        word-break: break-word;
        padding: 15px 60px 15px 15px;
        margin-left: 45px;
        display: block;
        line-height: 1.2;
        transition: color 0.4s;
    }

    li.item.completed label {
        color: #d9d9d9;
        text-decoration: line-through;
    }

    li.item button,
        li.item input[type="checkbox"] {
        outline: none;
    }

    li.item button {
        margin: 0;
        padding: 0;
        border: 0;
        background: none;
        font-size: 100%;
        vertical-align: baseline;
        font-family: inherit;
        font-weight: inherit;
        color: inherit;
        -webkit-appearance: none;
        appearance: none;
        -webkit-font-smoothing: antialiased;
        -moz-font-smoothing: antialiased;
        font-smoothing: antialiased;
    }

    li.item .destroy {
        position: absolute;
        top: 0;
        right: 10px;
        bottom: 0;
        width: 40px;
        height: 40px;
        margin: auto 0;
        font-size: 30px;
        color: #cc9a9a;
        margin-bottom: 11px;
        transition: color 0.2s ease-out;
    }

    li.item .destroy:hover {
        color: #af5b5e;
    }
</style>
<li class="item">
    <input type="checkbox" checked=${this.checked==="true"} onchange=${this._handleOnChecked}>
    <label>${this.text}</label>
    <button class="destroy" onclick=${this._handleOnRemoved}>x</button>
</li>
        `}}TodoItem.define("todo-item");